[
  {
    "id": "MDU6SXNzdWU1MTYwNTcyNDA=",
    "number": 1,
    "title": "【Q001】网站开发中，如何实现图片的懒加载",
    "body": "网站开发中，如何实现图片的懒加载，随着 web 技术的发展，他有没有一些更好的方案",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTEzMzE0NQ==",
          "body": "懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片\r\n\r\n故问题拆分成两个：\r\n\r\n1. 如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）\r\n2. 如何控制图片的加载\r\n\r\n## 方案一\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n`clientTop`，`offsetTop`，`clientHeight` 以及 `scrollTop` 各种关于图片的高度作比对\r\n\r\n这些高度都代表了什么意思？\r\n\r\n这我以前有可能是知道的，那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了\r\n\r\n**所以它有一个问题：复杂琐碎不好理解！**\r\n\r\n仅仅知道它静态的高度还不够，我们还需要知道动态的\r\n\r\n**如何动态？监听 `window.scroll` 事件**\r\n\r\n### 如何控制图片的加载\r\n\r\n``` html\r\n<img data-src=\"shanyue.jpg\">\r\n```\r\n\r\n首先设置一个临时属性 `data-src`，控制加载时使用 `src` 代替 `data-src`\r\n\r\n## 方案二\r\n\r\n改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n引入一个新的 API， **`Element.getBoundingClientRect()` 方法返回元素的大小及其相对于视口的位置。**\r\n\r\n<img alt=\"getBoundingClientRect示例图\" src=\"https://mdn.mozillademos.org/files/15087/rect.png\">\r\n\r\n那如何判断图片出现在了当前视口呢，根据示例图示意，代码如下，这个就比较好理解了，就可以很容易地背会(就可以愉快地去面试了)。\r\n\r\n``` js\r\n// clientHeight 代表当前视口的高度\r\nimg.getBoundingClientRect().top < document.documentElement.clientHeight\r\n```\r\n\r\n**监听 `window.scroll` 事件也优化一下**\r\n\r\n加个节流器，提高性能。工作中一般使用 `lodash.throttle` 就可以了，万能的 `lodash` 啊！\r\n\r\n``` js\r\n_.throttle(func, [wait=0], [options={}])\r\n```\r\n\r\n参考 [什么是防抖和节流，他们的应用场景有哪些](https://github.com/shfshanyue/Daily-Question/issues/3)\r\n\r\n## 方案三\r\n\r\n再改进一下\r\n\r\n### 如何判断图片出现在了当前视口\r\n\r\n**方案二使用的方法是: `window.scroll` 监听 `Element.getBoundingClientRect()` 并使用 `_.throttle` 节流**\r\n\r\n**一系列组合动作太复杂了，于是浏览器出了一个三合一事件: `IntersectionObserver` API，一个能够监听元素是否到了当前视口的事件，一步到位！**\r\n\r\n事件回调的参数是 [IntersectionObserverEntry](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry) 的集合，代表关于是否在可见视口的一系列值\r\n\r\n其中，`entry.isIntersecting` 代表目标元素可见\r\n\r\n``` javascript\r\nconst observer = new IntersectionObserver((changes) => {\r\n  // changes: 目标元素集合\r\n  changes.forEach((change) => {\r\n    // intersectionRatio\r\n    if (change.isIntersecting) {\r\n      const img = change.target\r\n      img.src = img.dataset.src\r\n      observer.unobserve(img)\r\n    }\r\n  })\r\n})\r\n\r\nobserver.observe(img)\r\n```\r\n\r\n**当然，`IntersectionObserver` 除了给图片做懒加载外，还可以对单页应用资源做预加载。**\r\n\r\n如在 `next.js v9` 中，会对视口内的资源做预加载，可以参考 [next 9 production optimizations](https://nextjs.org/blog/next-9#production-optimizations)\r\n\r\n``` jsx\r\n<Link href=\"/about\">\r\n  <a>关于山月</a>\r\n</Link>\r\n```\r\n\r\n## 方案四\r\n\r\n浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。实在是...！\r\n\r\n``` html\r\n<img src=\"shanyue.jpg\" loading=\"lazy\">\r\n```\r\n\r\n不过目前浏览器兼容性不太好，关于 `loading` 属性的文章也可以查看 [Native image lazy-loading for the web!](https://addyosmani.com/blog/lazy-loading/)\r\n",
          "star": {
            "totalCount": 6
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NzQwNTA1OQ==",
          "body": "兼容性\r\n方案1：all\r\n方案2：all\r\n方案3：ie不支持\r\n方案4: 除chrome几乎都不支持",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "zhaoguangyue",
            "url": "https://github.com/zhaoguangyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY0MjgxNDI=",
    "number": 2,
    "title": "【Q002】当 ping 一个 IP 地址时发生了什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTMzNjQ4Nw==",
          "body": "从 `ping` 的 `man` 手册就可以看出来，`ping` 实际上发送了 `ICMP ECHO_REQUEST` 的报文\r\n\r\n> ping -- send ICMP ECHO_REQUEST packets to network hosts\r\n\r\n通过让目标 IP 地址返回 `ICMP ECHO_RESPONSE` 报文来判断 IP 可不可达",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTUzMjA=",
    "number": 3,
    "title": "【Q003】什么是防抖和节流，他们的应用场景有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDM3MTU0MA==",
          "body": "####  防抖(debounce)\r\n触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间\r\n\r\n##### 示例代码\r\n```javascript\r\n    // 防抖函数\r\n    function debounce(fn, wait) {\r\n        let timer;\r\n        return function() {\r\n            let _this = this;\r\n            let args = arguments;\r\n            if(timer) { clearTimeout(timer) }\r\n            timer = setTimeout(function(){\r\n                fn.apply(_this, args)\r\n            }, wait);      \r\n        }\r\n    }\r\n    // 使用\r\n    window.onresize = debounce(function() {console.log('resize')}, 500)\r\n```\r\n\r\n#### 节流(throttle)\r\n高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率\r\n##### 示例代码\r\n\r\n```javascript\r\n    // 方式1: 使用时间戳\r\n    function throttle1(fn, wait) {\r\n        let time = 0;\r\n        return function() {\r\n            let _this = this;\r\n            let args = arguments;\r\n            let now = Date.now()\r\n            if(now - time > wait) {\r\n                fn.apply(_this, args);\r\n                time = now;\r\n            }\r\n        }\r\n    }\r\n    // 方式2: 使用定时器\r\n    function thorttle2(fn, wait) {\r\n        let timer;\r\n        return function () {\r\n            let _this = this;\r\n            let args = arguments;\r\n            \r\n            if(!timer) {\r\n                timer = setTimeout(function(){\r\n                    timer = null;\r\n                    fn.apply(_this, args)\r\n                }, wait)\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n上面`节流`和`防抖`实现方式比较简单，但是已经可以满足日常使用，如果想更近一步了解可以查看[underscore](https://www.bootcss.com/p/underscore/)和[lodash](https://www.lodashjs.com/docs/latest)文档中`debounce`和`thorttle`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xiaoai7904",
            "url": "https://github.com/xiaoai7904"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1Mzg5OTIzNw==",
          "body": "## 防抖 (debounce)\r\n\r\n防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。\r\n\r\n想要了解一个概念，必先了解概念所应用的场景。在 JS 这个世界中，有哪些防抖的场景呢\r\n\r\n1. 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖\r\n1. 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖\r\n1. 文本编辑器实时保存，当无任何更改操作一秒后进行保存\r\n\r\n代码如下，可以看出来**防抖重在清零 `clearTimeout(timer)`**\r\n\r\n``` js\r\nfunction debounce (f, wait) {\r\n  let timer\r\n  return (...args) => {\r\n    clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      f(...args)\r\n    }, wait)\r\n  }\r\n}\r\n```\r\n\r\n## 节流 (throttle)\r\n\r\n节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。\r\n\r\n1. `scroll` 事件，每隔一秒计算一次位置信息等\r\n1. 浏览器播放事件，每个一秒计算一次进度信息等\r\n1. input 框实时搜索并发送请求展示下拉列表，没隔一秒发送一次请求 (也可做防抖)\r\n\r\n代码如下，可以看出来**节流重在开关锁 `timer=null`**\r\n\r\n``` js\r\nfunction throttle (f, wait) {\r\n  let timer\r\n  return (...args) => {\r\n    if (timer) { return }\r\n    timer = setTimeout(() => {\r\n      f(...args)\r\n      timer = null\r\n    }, wait)\r\n  }\r\n}\r\n```\r\n\r\n## 总结 (简要答案)\r\n\r\n+ 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。代码实现重在清零 `clearTimeout`\r\n+ 节流：控制流量，单位时间内事件只能触发一次，如果服务器端的限流即 Rate Limit。代码实现重在开锁关锁 `timer=timeout; timer=null`",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTU2NzM=",
    "number": 4,
    "title": "【Q004】如何获取一个进程的内存并监控",
    "body": "在编写脚本时，有时会出现内存过大发生 OOM 的事情，那我们如何得知某个进程的内存？另外又如何监控它",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MjE4MQ==",
          "body": "通过 `ps` 可以获知一个进程所占用的内存\r\n\r\n``` bash\r\n$ ps -O rss -p 3506\r\n  PID   RSS S TTY          TIME COMMAND\r\n 3506  6984 S pts/1    00:00:00 vim\r\n```\r\n\r\n如果要监控内存，肯定使用对进程万能的命令 `pidstat` （PS: 这名字一听就知道是干嘛的）\r\n\r\n``` bash\r\n# -r 显示内存信息\r\n# -p 指定 pid\r\n# 1: 每个一秒打印一次\r\n$ pidstat -r -p 3506 1\r\nLinux 3.10.0-957.21.3.el7.x86_64 (shanyue)      11/04/19        _x86_64_        (2 CPU)\r\n\r\n20:47:35      UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command\r\n20:47:36        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:37        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:38        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:39        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:40        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n20:47:41        0      3506      0.00      0.00  139940   6984   0.18  vim\r\n```\r\n\r\n`pidstat` 是属于 `sysstat` 下的 linux 性能工具，但在 mac 中，如何定位内存的变化？此时可以使用万能的 `top/htop`\r\n\r\n ``` bash\r\n $ htop -p 31796\r\n ```\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/86353210-7b210080-bc99-11ea-9885-8e5ca1b909b5.png)\r\n\r\n## 总结\r\n\r\n简而言之，有以下三个命令\r\n\r\n1. `pidstat -r`\r\n1. `htop/top -p`\r\n1. `ps -O rss -p`\r\n\r\n关于更多指标的监控可以参考我的文章: [linux 各项监控指标小记](https://shanyue.tech/op/linux-monitor.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY4MTY0NDM=",
    "number": 6,
    "title": "【Q005】生产环境的某个接口报错，如何定位",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0NTU1Ng==",
          "body": "1. 测试环境有没有问题，有问题可以在测试环境测试\r\n1. 有没有异常报警系统，如 `sentry`，如果有在 `sentry` 中查看堆栈信息以及相关上下文，定位代码\r\n1. 如果堆栈信息不足够找到问题，看有没有链路追踪工具，如 `zipkin`。从 `sentry` 中找到 `requestId`，在数据库日志/上下游链路日志中查找对应 `requestId` 的日志\r\n1. 查看接口相关代码 \r\n\r\n既然报错，那么一定会在异常上报系统中找到 `Issue` 进行定位。最怕的是那种接口没报错，但是业务方反馈数据有误的问题了，只能开了 debug，进行代码调试了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc2NTMxMQ==",
          "body": "zipkin sleuth",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangxiaokun",
            "url": "https://github.com/zhangxiaokun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5MjM2NzU=",
    "number": 7,
    "title": "【Q006】如何写一个 SQL 获取分组 top n 的数据",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前三名",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTIzNDQxOQ==",
          "body": "通过一个自连接可以获取到\r\n\r\n``` sql\r\nselect id, class_id, score from student s1 where (\r\n  -- 对比每行 student，通过自连接找到该班中比该 student 分数要高与等于的人数，即排名\r\n  select count(*) from student s2 where s2.class_id = s1.class_id and s2.score >= s1.score\r\n) = 1\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5ODg0NTQ=",
    "number": 8,
    "title": "【Q007】如何写一个 SQL 获取分组 top 1 的数据 ",
    "body": "一个学校中的每个学生属于一个班级，如何获取每个班的前三名\r\n\r\n假设有学生表 `student(id, score, class_id)`，`score` 代表分数，`class_id` 代表班级，如何写出 SQL 取每个班级分数前一名\r\n\r\n与 [Top n](https://github.com/shfshanyue/Daily-Question/issues/7) 类似，不过有更简单的方法\r\n\r\n（当然考虑到并列情况就会复杂很多",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM0MzI2OA==",
          "body": "单纯的获取 Top 1，只需要 `group by` 加聚合函数，不过复杂的还是参考 [top n](https://github.com/shfshanyue/Daily-Question/issues/7)\r\n\r\n``` sql\r\nselect class_id, max(score) from student group by class_id\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTY5OTQ0NTk=",
    "number": 9,
    "title": "【Q008】当新入职一家公司时，如何快速搭建开发环境并让应用跑起来",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTM1MTAyOA==",
          "body": "这要看这家公司的基础设施怎么样了（当然面试时，最好在反问面试官环节问问这个问题）\r\n\r\n+ 查看是否有 `dockerfile`，如果有跟着 `dockerfile` 跑命令\r\n+ 查看是否有 `CI/CD`，如果有跟着 `CI/CD` 部署的脚本跑命令\r\n\r\n如果都没有，那只能到处问人自求多福了\r\n\r\n不过鉴于本地环境与开发环境部署的有可能不同（特别是前端，开发时需要起个 server），也有几个点需要注意\r\n\r\n1. 前端有可能在本地环境启动时需要依赖前端部署时所产生的文件，所以有时需要先正常部署一遍，再试着按照本地环境启动 (即需要先 `npm run build` 一下，再 `npm run dev`)\r\n1. 别忘了设置环境变量",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc1ODAwMTc=",
    "number": 10,
    "title": "【Q009】如何实现一个元素的水平垂直居中",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTEzMjAxNw==",
          "body": "绝对定位方法：\r\n```\r\n.box {\r\n  postion: absolute;\r\n  top: 50%;\r\n  bottom: 50%;\r\n  width: 50px;\r\n  height: 50px;\r\n  transform: translate(-50%, -50%);\r\n}\r\n<body>\r\n<div class=\"box\"><div>\r\n</body>\r\n```\r\n\r\nflex方法：\r\n```\r\nbody {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n.box {\r\n  width: 50px;\r\n  height: 50px;\r\n}\r\n\r\n<body>\r\n<div class=\"box\"><div>\r\n</body>\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "woohs",
            "url": "https://github.com/woohs"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTM1MTM2Nw==",
          "body": "提供一个较少提过的方法，使用 `grid`，它是做二维布局的，但是只有一个子元素时，一维布局与二维布局就一样了。结合 `justify-content`/`justify-items` 和 `align-content/align-items` 就有四种方案\r\n\r\n效果可以见 [codepen](https://codepen.io/shanyue/pen/ZEERzzL)\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-content: center;\r\n  align-content: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-items: center;\r\n  align-content: center;\r\n}\r\n```\r\n\r\n\r\n``` css\r\n.container {\r\n  display: grid;\r\n  justify-items: center;\r\n  align-items: center;\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTUzMTA5NQ==",
          "body": "引自：https://css-tricks.com/centering-css-complete-guide/\r\n1 该元素的宽高固定吗？\r\n在将元素绝对定位为top: 50%; left: 50%;后，可以使用值为宽的一半和高的一半的负margin实现垂直水平居中。（跨浏览器支持很不错）\r\n```\r\n.parent {\r\n  position: relative;\r\n}\r\n\r\n.child {\r\n  width: 300px;\r\n  height: 100px;\r\n  padding: 20px;\r\n\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n\r\n  margin: -70px 0 0 -170px;\r\n}\r\n```\r\n2 该元素宽高未知？\r\n（1）如果宽高未知，在将元素绝对定位为top: 50%; left: 50%;后，可以使用transform属性来做负的50%移动（基于当前元素宽高）。\r\n```\r\n.parent {\r\n  position: relative;\r\n}\r\n.child {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n（2）也可以元素相对父容器绝对定位(left: 0;right: 0;top: 0;bottom: 0;)并margin: auto，不需要提前知道尺寸兼容性好。\r\n```\r\n.container {\r\n  position: relative;\r\n  height: 300px;\r\n  border: 1px solid red;\r\n}\r\n.item {\r\n  width: 100px;\r\n  height: 50px;\r\n  position: absolute;\r\n  left: 0;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  border: 1px solid green;\r\n}\r\n```\r\n3 你要用flexbox吗？\r\n对flexbox进行垂直水平居中，只需设置两个属性为center: align-items、justify-content。\r\n```\r\n.parent {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n```\r\n4 你要用grid布局吗？\r\n父容器设置为grid布局后，子元素直接margin: auto;即可实现垂直水平居中。\r\n```\r\nbody, html {\r\n  height: 100%;\r\n  display: grid;\r\n}\r\nspan { /* thing to center */\r\n  margin: auto;\r\n}\r\n```\r\n详细案例解释可参考：https://zhuanlan.zhihu.com/p/87134477",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTA0MTY=",
    "number": 11,
    "title": "【Q010】了解 React 中的 ErrorBoundary 吗，它有那些使用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4Mjg3OQ==",
          "body": "待答",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzAzNjkwMw==",
          "body": "从其他文章里看到的 避免错误渲染白屏做异常中间处理的嵌套组件\r\nclass ErrorBoundary extends Component {\r\n  static getDerivedStateFromError() {\r\n    return { hasError: true };\r\n  }\r\n  state = {\r\n    hasError: false,\r\n  };\r\n  componentDidCatch(error, info) {\r\n    // reportError(error, info);\r\n  }\r\n  render() {\r\n    const { hasError } = this.state;\r\n    const { children } = this.props;\r\n    if (hasError) {\r\n      return <div>系统异常，请稍后再试</div>;\r\n    }\r\n    return children;\r\n  }\r\n}\r\nfunction render(Component, props) {\r\n  const rootElement = document.getElementById(\"root\");\r\n  ReactDOM.render(\r\n    <ErrorBoundary>\r\n      <Component {...props} />\r\n    </ErrorBoundary>,\r\n    rootElement\r\n  );\r\n}\r\n\r\n作者：蚂蚁保险体验技术\r\n链接：https://juejin.im/post/5de91d0f51882512400acafd\r\n来源：掘金\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "geekftz",
            "url": "https://github.com/geekftz"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk1OTE0Mw==",
          "body": "是 react 内的一个钩子，用于在组件内发生了 js 错误时候的错误处理。\r\n使用场景是在发生 js 报错的时候不至于说白屏，可以转去别的页面提示用户这里报了错，转用别的去到去继续操作。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "BertieGo",
            "url": "https://github.com/BertieGo"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTAxODEyMw==",
          "body": "这不就是try catch么。。。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "baihech",
            "url": "https://github.com/baihech"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTAxODI3NQ==",
          "body": "错误不抛出，交给catch处理，然鹅并不能预先知道错误类型。。。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "baihech",
            "url": "https://github.com/baihech"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3MjM1MA==",
          "body": "[前端防御性编程](https://juejin.im/post/5de91d0f51882512400acafd#heading-9)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUyOTQ2Nw==",
          "body": "了解，在推出之前报错会直接白屏，总是需要我们前端进行手动try catch，react16新增了两个生命周期componentdidcatch和static getDerivedStateFromError从框架级别让我们更方便捕捉异常并显示备用ui。其实就是在整个workloop外面包一层try catch，报错时候遍历父组件找到这两个生命周期并把堆栈信息塞给生命周期进行判断。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUyOTYyNA==",
          "body": "顺带一句suspense的原理好像也是这个",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTc2MTIxNTM=",
    "number": 12,
    "title": "【Q011】vue3.0 中为什么要使用 Proxy，它相比以前的实现方式有什么改进",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDM3MTk0OQ==",
          "body": "简单描述就是: 性能更好，解决无法监听数组变化问题",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xiaoai7904",
            "url": "https://github.com/xiaoai7904"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxODk2MDQ=",
    "number": 13,
    "title": "【Q012】helm v3 中为什么要弃用 tiller",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc3NjMxNA==",
          "body": "`helm` v2 中，`helm client` 通过 gRPC 把 `Chart` 交给 `tiller`。`tiller` 是 k8s 中的一个 `pod`，在 `k8s` 集群中根据 `Chart` 以及配置信息部署资源，架构图如下\r\n\r\n![https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg](https://supergiant.io/wp-content/uploads/2018/11/helm-workflow-new.jpg)\r\n\r\n这有一个问题，`tiller` 有一个最高权限的 RBAC，而运维，开发众多权限不同的人都可以通过 `tiller` 这个最高权限来部署新的应用，会产生相应的安全问题。\r\n\r\n于是，`helm v3` 去掉了 `tiller`，它的权限控制基于操作人员的 `kubeconfig`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTIzNTg=",
    "number": 14,
    "title": "【Q013】有没有使用过 react hooks，它带来了那些便利",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODI0NDg1NA==",
          "body": "依我的看法，`React hooks` 主要解决了状态以及副作用难以复用的场景，除此之外，他对我最大的好处就是在 `Console` 中不会看到重重叠叠相同名字的组件了(HOC)。\r\n\r\n目前使用感觉最爽的两个hook，都是关于请求的。一个是 `apollo-client` 的 `useQuery`，一个是 [swr](https://github.com/zeit/swr)。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3MjYxMw==",
          "body": "1.HOC嵌套地狱\r\n2.this\r\n3.逻辑复用\r\n3.tree-shaking",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTgxOTU3NDc=",
    "number": 15,
    "title": "【Q014】如何使用 react hooks 实现一个计数器的组件",
    "body": "如何使用 react hooks 实现最简单一个计数器的组件\r\n\r\n为了保证最最简单化，不需要暂停与开始状态",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk0NjY4MQ==",
          "body": "```\r\nimport React, { useState, useEffect } from 'react'\r\nimport useCountDown from './useCountDown'\r\n\r\nconst useCountDown = (num) => {\r\n    const [seconds, setSecond] = useState(num)\r\n\r\n    useEffect(() => {\r\n        setTimeout(() => {\r\n            if (seconds > 0) {\r\n                setSecond(c => c - 1);\r\n            }\r\n        }, 1000);\r\n    }, [seconds]);\r\n\r\n    return [seconds, setSecond]\r\n}\r\n\r\n// use it\r\nconst Demo = () => {\r\n    const [seconds, setSecond] = useCountDown(0)\r\n    return (\r\n             <Button \r\n                disable={seconds !== 0} \r\n                onClick={() => setSecond(59)} \r\n            >\r\n                {seconds > 0 ? `${seconds}s后可点击` : '点击开始倒计时'}\r\n            </Button>\r\n        )\r\n}\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "Hack-Jay",
            "url": "https://github.com/Hack-Jay"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk0NzQ2Mw==",
          "body": "``` js\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\nfunction App() {\r\n    const [count, setCount] = useState(0);\r\n    useEffect(() => {\r\n        setInterval(() => {\r\n            setCount(count => count + 1)\r\n        }, 1000)\r\n    }, [])\r\n\r\n    return <h1>{count}</h1>\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "bWhirring",
            "url": "https://github.com/bWhirring"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk2MjY4Mg==",
          "body": "```js\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\nfunction App() {\r\n    const [count, setCount] = useState(0);\r\n    useEffect(() => {\r\n        const timer = setInterval(() => {\r\n            setCount(count => count + 1)\r\n        }, 1000)\r\n\r\n        return () => {\r\n           clearInterval(timer)\r\n        }\r\n    }, [])\r\n\r\n    return <h1>{count}</h1>\r\n}\r\n```",
          "star": {
            "totalCount": 12
          },
          "author": {
            "login": "Euron-X",
            "url": "https://github.com/Euron-X"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTkxNjI4Nzg=",
    "number": 16,
    "title": "【Q015】你们的前端项目是如何在线上部署的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTA3MDkyMA==",
          "body": "> 今天正好写了一篇长文来回答这个问题\r\n\r\n前端一说起刀耕火种，那肯定紧随着前端工程化这一话题。随着 `react`/`vue`/`angular`，`es6+`，`webpack`，`babel`，`typescript` 以及 `node` 的发展，前端已经在逐渐替代过去 script 引 cdn 开发的方式了，掀起了工程化这一大浪潮。得益于工程化的发展与开源社区的良好生态，前端应用的可用性与效率得到了很大提高。\r\n\r\n前端以前是刀耕火种，那前端应用部署在以前也是刀耕火种。那前端应用部署的发展得益于什么，随前端工程化带来的副产品？\r\n\r\n这只是一部分，而更重要的原因是 `devops` 的崛起。\r\n\r\n为了更清晰地理解前端部署的发展史，了解部署时运维和前端（或者更广泛地说，业务开发人员）的职责划分，当每次前端部署发生改变时，可以思考两个问题\r\n\r\n1. 缓存，前端应用中http 的 `response header` 由谁来配？得益于工程化发展，可以对打包后得到带有 hash 值的文件可以做永久缓存\r\n1. 跨域，`/api` 的代理配置由谁来配？在开发环境前端可以开个小服务，启用 `webpack-dev-server` 配置跨域，那生产环境呢\r\n\r\n这两个问题都是前端面试时的高频问题，但话语权是否掌握在前端手里\r\n\r\n时间来到 `React` 刚刚发展起来的这一年，这时已经使用 `React` 开发应用，使用 `webpack` 来打包。但是前端部署，仍是刀耕火种\r\n\r\n## 刀耕火种\r\n\r\n一台跳板机\r\n\r\n一台生产环境服务器\r\n\r\n一份部署脚本\r\n\r\n前端调着他的 `webpack`，开心地给运维发了部署邮件并附了一份部署脚本，想着第一次不用套后端的模板，第一次前端可以独立部署。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n运维照着着前端发过来的部署邮件，一遍又一遍地拉着代码，改着配置，写着 `try_files`， 配着 `proxy_pass`。\r\n\r\n这时候，前端静态文件由 `nginx` 托管，`nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    # 避免非root路径404\r\n    try_files $uri $uri/ /index.html;\r\n  }\r\n\r\n  # 解决跨域\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n\r\n  # 为带 hash 值的文件配置永久缓存\r\n  location ~* \\.(?:css|js)$ {\r\n      try_files $uri =404;\r\n      expires 1y;\r\n      add_header Cache-Control \"public\";\r\n  }\r\n\r\n  location ~ ^.+\\..+$ {\r\n      try_files $uri =404;\r\n  }\r\n}\r\n```\r\n\r\n不过...经常有时候跑不起来\r\n\r\n运维抱怨着前端的部署脚本没有标好 `node` 版本，前端嚷嚷着测试环境没问题\r\n\r\n这个时候运维需要费很多心力放在部署上，甚至测试环境的部署上，前端也要操心放在运维如何部署上。这个时候由于怕影响线上环境，上线往往选择在深夜，前端和运维身心俱疲\r\n\r\n不过向来如此\r\n\r\n鲁迅说，向来如此，那便对么。\r\n\r\n**这个时候，无论跨域的配置还是缓存的配置，都是运维来管理，运维不懂前端。但配置方式却是前端在提供，而前端并不熟悉 nginx**\r\n\r\n## 使用 docker 构建镜像\r\n\r\n`docker` 的引进，很大程度地解决了部署脚本跑不了这个大BUG。**`dockerfile` 即部署脚本，部署脚本即 `dockerfile`**。也很大程度缓解了前端运维的摩擦，毕竟前端越来越靠谱了，至少部署脚本没有问题了 (笑\r\n\r\n这时候，前端不再提供静态资源，而是提供服务，一个 `http` 服务\r\n\r\n前端写的 `dockerfile` 大致长这个样子\r\n\r\n``` dockerfile\r\nFROM node:alpine\r\n\r\n# 代表生产环境\r\nENV PROJECT_ENV production\r\n# 许多 package 会根据此环境变量，做出不同的行为\r\n# 另外，在 webpack 中打包也会根据此环境变量做出优化，但是 create-react-app 在打包时会写死该环境变量\r\nENV NODE_ENV production\r\nWORKDIR /code\r\nADD . /code\r\nRUN npm install && npm run build && npm install -g http-server\r\nEXPOSE 80\r\n\r\nCMD http-server ./public -p 80\r\n```\r\n\r\n单单有 `dockerfile` 也跑不起来，另外前端也开始维护一个 `docker-compose.yaml`，交给运维执行命令 `docker-compose up -d` 启动前端应用。前端第一次写 `dockerfile` 与 `docker-compose.yaml`，在部署流程中扮演的角色越来越重要。想着自己基础盘进一步扩大，前端不禁开心地笑了\r\n\r\n``` yaml\r\nversion: \"3\"\r\nservices:\r\n  shici:\r\n    build: .\r\n    expose:\r\n      - 80\r\n```\r\n\r\n\r\n运维的 `nginx` 配置文件大致长这个样子\r\n\r\n``` conf\r\nserver {\r\n  listen 80;\r\n  server_name shanyue.tech; \r\n\r\n  location / {\r\n    proxy_pass http://static.shanyue.tech;\r\n  }\r\n\r\n  location /api {\r\n    proxy_pass http://api.shanyue.tech;\r\n  }\r\n}\r\n```\r\n\r\n运维除了配置 `nginx` 之外，还要执行一个命令: `docker-compose up -d`\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，由于从静态文件转换为服务，缓存开始交由前端控制 (但是镜像中的 `http-server` 不太适合做这件事情)\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n前端可以做他应该做的事情中的一部分了，这是一件令人开心的事情\r\n\r\n当然，前端对于 `dockerfile` 的改进也是一个慢慢演进的过程，那这个时候镜像有什么问题呢？\r\n\r\n1. 构建镜像体积过大\r\n1. 构建镜像时间过长\r\n\r\n## 使用多阶段构建优化镜像\r\n\r\n这中间其实经历了不少坎坷，其中过程如何，详见我的另一篇文章: [如何使用 docker 部署前端应用](https://juejin.im/post/5c83cbaa6fb9a04a0f65fdaa)。\r\n\r\n其中主要的优化也是在上述所提到的两个方面\r\n\r\n1. 构建镜像体积由 1G+ 变为 10M+\r\n1. 构建镜像时间由 5min+ 变为 1min (视项目复杂程度，大部分时间在构建时间与上传静态资源时间)\r\n\r\n``` dockerfile\r\nFROM node:alpine as builder\r\n\r\nENV PROJECT_ENV production\r\nENV NODE_ENV production\r\n\r\nWORKDIR /code\r\n\r\nADD package.json /code\r\nRUN npm install --production\r\n\r\nADD . /code\r\n\r\n# npm run uploadCdn 是把静态资源上传至 oss 上的脚本文件，将来会使用 cdn 对 oss 加速\r\nRUN npm run build && npm run uploadCdn\r\n\r\n# 选择更小体积的基础镜像\r\nFROM nginx:alpine\r\nCOPY --from=builder code/public/index.html code/public/favicon.ico /usr/share/nginx/html/\r\nCOPY --from=builder code/public/static /usr/share/nginx/html/static\r\n```\r\n\r\n那它怎么做的\r\n\r\n1. 先 `ADD package.json /code`, 再 `npm install --production` 之后 `Add` 所有文件。充分利用镜像缓存，减少构建时间\r\n1. 多阶段构建，大大减小镜像体积\r\n\r\n另外还可以有一些小优化，如\r\n\r\n+ `npm cache` 的基础镜像或者 `npm` 私有仓库，减少 `npm install` 时间，减小构建时间\r\n+ `npm install --production` 只装必要的包\r\n\r\n前端看着自己优化的 `dockerfile`，想着前几天还被运维吵，说什么磁盘一半的空间都被前端的镜像给占了，想着自己节省了前端镜像几个数量级的体积，为公司好像省了不少服务器的开销，想着自己的基础盘进一步扩大，不禁开心的笑了\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制，缓存在oss上设置，将会使用 cdn 对 oss 加速。此时缓存由前端写脚本控制\r\n1. 跨域，跨域仍由运维在 `nginx` 中配置\r\n\r\n## CI/CD 与 gitlab\r\n\r\n此时前端成就感爆棚，运维呢？运维还在一遍一遍地上线，重复着一遍又一遍的部署三个动作\r\n\r\n1. 拉代码\r\n1. `docker-compose up -d`\r\n1. 重启 nginx\r\n\r\n运维觉得再也不能这么下去了，于是他引进了 `CI`: 与现有代码仓库 `gitlab` 配套的 `gitlab ci`\r\n\r\n+ `CI`，`Continuous Integration`，持续集成\r\n+ `CD`，`Continuous Delivery`，持续交付\r\n\r\n重要的不是 `CI/CD` 是什么，重要的是现在运维不用跟着业务上线走了，不需要一直盯着前端部署了。这些都是 `CI/CD` 的事情了，它被用来做自动化部署。上述提到的三件事交给了 `CI/CD`\r\n\r\n`.gitlab-ci.yml` 是 `gitlab` 的 CI 配置文件，它大概长这个样子\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker-compose up --build -d\r\n  tags:\r\n    - shell\r\n```\r\n\r\n`CI/CD` 不仅仅更解放了业务项目的部署，也在交付之前大大加强了业务代码的质量，它可以用来 `lint`，`test`，`package` 安全检查，甚至多特性多环境部署，我将会在我以后的文章将这部分事情\r\n\r\n我的一个服务器渲染项目 [shfshanyue/shici](https://github.com/shfshanyue/shici) 以前在我的服务器中就是以 `docker`/`docker-compose/gitlab-ci` 的方式部署，有兴趣的可以看看它的配置文件\r\n\r\n+ [shfshanyue/shici:Dockerfile](https://github.com/shfshanyue/shici/blob/master/Dockerfile)\r\n+ [shfshanyue/shici:docker-compose.yml](https://github.com/shfshanyue/shici/blob/master/docker-compose.yml)\r\n+ [shfshanyue/shici:gitlab-ci.yml](https://github.com/shfshanyue/shici/blob/master/.gitlab-ci.yml)\r\n\r\n如果你有个人服务器的话，也建议你做一个自己感兴趣的前端应用和配套的后端接口服务，并且配套 `CI/CD` 把它部署在自己的自己服务器上\r\n\r\n而你如果希望结合 `github` 做 `CI/CD`，那可以试一试 `github` + `github action`\r\n\r\n另外，也可以试试 `drone.ci`，如何部署可以参考我以前的文章: [github 上持续集成方案 drone 的简介及部署](https://juejin.im/post/5dc0b563f265da4cef190b8a)\r\n\r\n## 使用 kubernetes 部署\r\n\r\n随着业务越来越大，镜像越来越多，`docker-compose` 已经不太能应付，`kubernetes` 应时而出。这时服务器也从1台变成了多台，多台服务器就会有分布式问题\r\n\r\n**一门新技术的出现，在解决以前问题的同时也会引进复杂性。**\r\n\r\nk8s 部署的好处很明显: 健康检查，滚动升级，弹性扩容，快速回滚，资源限制，完善的监控等等\r\n\r\n那现在遇到的新问题是什么？\r\n\r\n**构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**\r\n\r\n需要一个私有的镜像仓库，这是运维的事情，`harbor` 很快就被运维搭建好了，但是对于前端部署来说，复杂性又提高了\r\n\r\n先来看看以前的流程:\r\n\r\n1. 前端配置 `dockerfile` 与 `docker-compose`\r\n1. 生产环境服务器的 `CI runner` 拉代码(可以看做以前的运维)，`docker-compose up -d` 启动服务。然后再重启 `nginx`，做反向代理，对外提供服务\r\n\r\n以前的流程有一个问题: **构建镜像的服务器，提供容器服务的服务器，做持续集成的服务器是一台！**，所以需要一个私有的镜像仓库，一个能够访问 `k8s` 集群的持续集成服务器\r\n\r\n流程改进之后结合 `k8s` 的流程如下\r\n\r\n1. 前端配置 `dockerfile`，构建镜像，推到镜像仓库\r\n1. 运维为前端应用配置 `k8s` 的资源配置文件，`kubectl apply -f` 时会重新拉取镜像，部署资源\r\n\r\n运维问前端，需不需要再扩大下你的基础盘，写一写前端的 `k8s` 资源配置文件，并且列了几篇文章\r\n\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n\r\n前端看了看后端十几个 k8s 配置文件之后，摇摇头说算了算了\r\n\r\n这个时候，`gitlab-ci.yaml` 差不多长这个样子，配置文件的权限由运维一人管理\r\n\r\n``` yaml\r\ndeploy:\r\n  stage: deploy\r\n  only:\r\n    - master\r\n  script:\r\n    - docker build -t harbor.shanyue.tech/fe/shanyue\r\n    - docker push harbor.shanyue.tech/fe/shanyue\r\n    - kubectl apply -f https://k8s-config.default.svc.cluster.local/shanyue.yaml\r\n  tags:\r\n    - shell\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域仍由运维控制，在后端 `k8s` 资源的配置文件中控制 `Ingress`\r\n\r\n## 使用 helm 部署\r\n\r\n这时前端与运维已不太往来，除了偶尔新起项目需要运维帮个忙以外\r\n\r\n但好景不长，突然有一天，前端发现自己连个环境变量都没法传！于是经常找运维修改配置文件，运维也不胜其烦\r\n\r\n于是有了 `helm`，如果用一句话解释它，那它就是一个带有模板功能的 `k8s` 资源配置文件。作为前端，你只需要填参数。更多详细的内容可以参考我以前的文章 [使用 helm 部署 k8s 资源](https://juejin.im/post/5dbf7909f265da4d4b5fe7b4)\r\n\r\n假如我们使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 作为 `helm chart`，前端可能写的配置文件长这个样子\r\n\r\n``` yaml\r\nimage:\r\n  registry: harbor.shanyue.tech\r\n  repository: fe/shanyue\r\n  tag: 8a9ac0\r\n\r\ningress:\r\n  enabled: true\r\n  hosts:\r\n  - name: shanyue.tech\r\n    path: /\r\n\r\n  tls:\r\n  - hosts:\r\n      - shanyue.tech\r\n    secretName: shanyue-tls\r\n\r\n    # livenessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 30\r\n    #   timeoutSeconds: 5\r\n    #   failureThreshold: 6\r\n    # \r\n    # readinessProbe:\r\n    #   httpGet:\r\n    #     path: /\r\n    #     port: http\r\n    #   initialDelaySeconds: 5\r\n    #   timeoutSeconds: 3\r\n    #   periodSeconds: 5\r\n```\r\n\r\n这时候再思考文章最前面两个问题\r\n\r\n1. 缓存，缓存由前端控制\r\n1. 跨域，跨域由后端控制，配置在后端 Chart 的配置文件 `values.yaml` 中\r\n\r\n到了这时前端和运维的职责所在呢？\r\n\r\n前端需要做的事情有:\r\n\r\n1. 写前端构建的 `dockerfile`，这只是一次性的工作，而且有了参考\r\n1. 使用 `helm` 部署时指定参数\r\n\r\n那运维要做的事情呢\r\n\r\n1. 提供一个供所有前端项目使用的 `helm chart`，甚至不用提供，如果运维比较懒那就就使用 [bitnami/nginx](https://hub.helm.sh/charts/bitnami/nginx) 吧。也是一次性工作\r\n1. 提供一个基于 `helm` 的工具，禁止业务过多的权限，甚至不用提供，如果运维比较懒那就直接使用 `helm`\r\n\r\n这时前端可以关注于自己的业务，运维可以关注于自己的云原生，职责划分从未这般清楚\r\n\r\n## 统一前端部署平台\r\n\r\n后来运维觉得前端应用的本质是一堆静态文件，较为单一，容易统一化，来避免各个前端镜像质量的参差不齐。于是运维准备了一个统一的 `node` 基础镜像\r\n\r\n前端再也不需要构建镜像，上传 CDN 了，他只需要写一份配置文件就可以了，大致长这个样子\r\n\r\n``` yaml\r\nbuild:\r\n  command: npm run build\r\n  dist: /dist\r\n\r\nhosts:\r\n- name: shanyue.tech\r\n  path: /\r\n\r\nheaders:\r\n- location: /*\r\n  values:\r\n  - cache-control: max-age=7200\r\n- location: assets/*\r\n  values:\r\n  - cache-control: max-age=31536000\r\n\r\nredirects:\r\n- from : /api\r\n  to: https://api.shanyue.tech\r\n  status: 200\r\n```\r\n\r\n此时，前端只需要写一份配置文件，就可以配置缓存，配置 `proxy`，做应该属于前端做的一切，而运维也再也不需要操心前端部署的事情了\r\n\r\n前端看着自己刚刚写好的配置文件，怅然若失的样子...\r\n\r\n不过一般只有大厂会有这么完善的前端部署平台，如果你对它有兴趣，你可以尝试下 `netlify`，可以参考我的文章: [使用 netlify 部署你的前端应用](https://shanyue.tech/op/deploy-fe-with-netlify.html)\r\n\r\n## 服务端渲染与后端部署\r\n\r\n大部分前端应用本质上是静态资源，剩下的少部分就是服务端渲染了，服务端渲染的本质上是一个后端服务，它的部署可以视为后端部署\r\n\r\n后端部署的情况更为复杂，比如\r\n\r\n1. 配置服务，后端需要访问敏感数据，但又不能把敏感数据放在代码仓库。你可以在 `environment variables`， `consul` 或者 `k8s configmap` 中维护\r\n1. 上下链路服务，你需要依赖数据库，上游服务\r\n1. 访问控制，限制 IP，黑白名单\r\n1. RateLimit\r\n1. 等等\r\n\r\n我将在以后的文章分享如何在 k8s 中部署一个后端\r\n\r\n## 小结\r\n\r\n随着 `devops` 的发展，前端部署越来越简单，可控性也越来越高，建议所有人都稍微学习一下 `devops` 的东西。\r\n\r\n道阻且长，行则将至。\r\n\r\n## 相关文章\r\n\r\n+ [个人服务器运维指南](https://juejin.im/post/5db7a9e2f265da4cf85d6fb9)\r\n+ [如果你想搭建一个博客](https://juejin.im/post/5db78500f265da4d0a68cef7)\r\n+ [当我有一台服务器时我做了什么](https://juejin.im/post/5c9232a8e51d45729b3b71e1)\r\n+ [使用 k8s 部署你的第一个应用: Pod，Deployment 与 Service](https://juejin.im/post/5db8c2b46fb9a020256692dc)\r\n+ [使用 k8s 为你的应用配置域名: Ingress](https://juejin.im/post/5db8da4b6fb9a0204520b310)\r\n+ [使用 k8s 为你的域名加上 https](https://juejin.im/post/5db8d94be51d4529f73e2833)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk1OTg4MDg=",
    "number": 17,
    "title": "【Q016】后端的敏感数据在生产环境是如何配置的",
    "body": "后端的敏感数据在生产环境是如何配置的，如数据库的账号密码，jwt 的 secret，联调上游服务的 token 等",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MTM0NjI1OA==",
          "body": "目前我们的方式是在每次部署之前，在 [vault](https://github.com/hashicorp/vault) 和 [consul](https://github.com/hashicorp/consul) 拉取敏感数据，写在配置文件中\r\n\r\n另外，还有几种可选的方案\r\n\r\n1. 跟随 `CI/CD` 的环境变量，敏感配置放在 CI 平台\r\n1. 跟随 k8s `secret`/`configMap`，敏感配置放在 k8s 集群\r\n1. 跟随专有的配置服务，如 `consul`/`vault`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTY3NjQ=",
    "number": 18,
    "title": "【Q017】css 如何实现左侧固定300px，右侧自适应的布局",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjQxMzkzMA==",
          "body": "css---\r\n .box{\r\n            width:100%;;\r\n            height:100%;\r\n            display:flex;\r\n        }\r\n        .one{\r\n            width:300px;\r\n            height:300px;\r\n            background-color: #afa;\r\n        }\r\n        .two{\r\n            flex:1;\r\n            height:300px;\r\n            background-color: #ae5aca;\r\n        }\r\nhtml----\r\n <div class=\"box\">\r\n        <div class=\"one\">12312313</div>\r\n        <div class=\"two\">123</div>\r\n    </div>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhaochongzi",
            "url": "https://github.com/zhaochongzi"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODY1NTA5NQ==",
          "body": "使用 `flex` 布局，左侧 `330px`，右侧 `flex-grow: 1`。`pug` 代码及 `css` 代码示例如下\r\n\r\n``` pug\r\n.container\r\n  .left\r\n  .main\r\n```\r\n\r\n``` css\r\n.container {\r\n  display: flex;\r\n}\r\n\r\n.left {\r\n  flex-basis: 330px;\r\n}\r\n\r\n.main {\r\n  flex-grow: 1;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5MzcyNjI0MA==",
          "body": "左侧300px；右侧flex: 1; 采用flex的固比模型",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Uwah",
            "url": "https://github.com/Uwah"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwMzYwMjA2OQ==",
          "body": "使用calc方法\r\n.left{width:330px;}\r\n.right{width: calc(100% - 330px)}",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "bohancen",
            "url": "https://github.com/bohancen"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MTk5NTk0MTI=",
    "number": 19,
    "title": "【Q018】当你使用 docker 部署应用时，如何查看应用日志",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MjQ0MjU4NA==",
          "body": "在docker中使用 `docker logs CONTAINER`\r\n\r\n如果在k8s中使用 `kubectl logs POD`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0MjExNDI=",
    "number": 20,
    "title": "【Q019】如何实现选中复制的功能",
    "body": "在一些博客系统，如掘金的博客中，可以复制代码，它是如何实现的",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MjA5OTE2NQ==",
          "body": "它一般可以使用第三方库 [clipboard.js](https://github.com/zenorocha/clipboard.js) 来实现，源码很简单，可以读一读\r\n\r\n主要有两个要点\r\n\r\n1. 选中: `Selection API`\r\n1. 复制: `document.execCommand`\r\n\r\n## 选中\r\n\r\n选中主要利用了 [Selection API](https://developer.mozilla.org/en-US/docs/Web/API/Selection)\r\n\r\n选中的代码如下\r\n\r\n``` js\r\nconst selection = window.getSelection();\r\nconst range = document.createRange();\r\n\r\nrange.selectNodeContents(element);\r\nselection.removeAllRanges();\r\nselection.addRange(range);\r\n\r\nselectedText = selection.toString();\r\n```\r\n\r\n取消选中的代码如下\r\n\r\n``` js\r\nwindow.getSelection().removeAllRanges();\r\n```\r\n\r\n它有现成的第三方库可以使用: [select.js](https://github.com/zenorocha/select)\r\n\r\n## 复制\r\n\r\n复制就比较简单了，`execCommand`\r\n\r\n``` js\r\ndocument.exec('copy')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA0Mjc1NzU=",
    "number": 21,
    "title": "【Q020】如何实现一个分布式锁",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc2NTk0NA==",
          "body": "mysql,redis,zk redis效率较高\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangxiaokun",
            "url": "https://github.com/zhangxiaokun"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc3OTIwMg==",
          "body": "多节点部署就会产生分布式问题，解决分布式问题就要找一个大家都能够访问到的中介，比如 `Redis`，`Consul`，`Zookeeper`\r\n\r\n以下是一个 `redis` 实现的操作\r\n\r\n`set User:10086 Random:shanyue EX 100 NX`\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjU4MDk=",
    "number": 22,
    "title": "【Q021】React 中，cloneElement 与 createElement 各是什么，有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODc0MQ==",
          "body": "首参不一样，直接上 API\r\n\r\n``` js\r\nReact.cloneElement(\r\n  element,\r\n  [props],\r\n  [...children]\r\n)\r\n\r\nReact.createElement(\r\n  type,\r\n  [props],\r\n  [...children]\r\n)\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY4MzA=",
    "number": 23,
    "title": "【Q022】如何实现一个简单的 Promise",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjA0Mg==",
          "body": "一个简单的 `Promise` 的粗糙实现，关键点在于\r\n\r\n1. 当 `pending` 时， `thenable` 函数由一个队列维护\r\n1. 当状态变为 `resolved(fulfilled)` 时，队列中所有 `thenable` 函数执行\r\n1. 当 `resolved` 时， `thenable` 函数直接执行\r\n\r\n<!--more-->\r\n\r\n`rejected` 状态同理\r\n\r\n```javascript\r\nclass Prom {\r\n  static resolve (value) {\r\n    if (value && value.then) {\r\n      return value \r\n    }\r\n    return new Prom(resolve => resolve(value))\r\n  }\r\n\r\n  constructor (fn) {\r\n    this.value = undefined\r\n    this.reason = undefined\r\n    this.status = 'PENDING'\r\n\r\n    // 维护一个 resolve/pending 的函数队列\r\n    this.resolveFns = []\r\n    this.rejectFns = []\r\n\r\n    const resolve = (value) => {\r\n      // 注意此处的 setTimeout\r\n      setTimeout(() => {\r\n        this.status = 'RESOLVED'\r\n        this.value = value\r\n        this.resolveFns.forEach(({ fn, resolve: res, reject: rej }) => res(fn(value)))\r\n      })\r\n    }\r\n\r\n    const reject = (e) => {\r\n      setTimeout(() => {\r\n        this.status = 'REJECTED'\r\n        this.reason = e\r\n        this.rejectFns.forEach(({ fn, resolve: res, reject: rej }) => rej(fn(e)))\r\n      })\r\n    }\r\n\r\n    fn(resolve, reject)\r\n  }\r\n\r\n\r\n  then (fn) {\r\n    if (this.status === 'RESOLVED') {\r\n      const result = fn(this.value)\r\n      // 需要返回一个 Promise\r\n      // 如果状态为 resolved，直接执行\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      // 也是返回一个 Promise\r\n      return new Prom((resolve, reject) => {\r\n        // 推进队列中，resolved 后统一执行\r\n        this.resolveFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n\r\n  catch (fn) {\r\n    if (this.status === 'REJECTED') {\r\n      const result = fn(this.value)\r\n      return Prom.resolve(result)\r\n    }\r\n    if (this.status === 'PENDING') {\r\n      return new Prom((resolve, reject) => {\r\n        this.rejectFns.push({ fn, resolve, reject }) \r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nProm.resolve(10).then(o => o * 10).then(o => o + 10).then(o => {\r\n  console.log(o)\r\n})\r\n\r\nreturn new Prom((resolve, reject) => reject('Error')).catch(e => {\r\n  console.log('Error', e)\r\n})\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA1NjY5ODI=",
    "number": 24,
    "title": "【Q023】websocket 服务多节点部署时会有什么问题，怎么解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4NzQ4MA==",
          "body": "## 多节点问题\r\n\r\n在开始思考分布式会有什么问题时，先来回答一个问题: 服务端如何与客户端交流？\r\n\r\n在 ws 服务端，当与客户端连接成功后，会生成一个对象 `connection`，ws 会维护一个与客户端所有连接的 `connections`。如果想要主动推送消息到客户端，只需要调用API `connection.sendText(message)`。\r\n\r\n那如何给所有人广播消息呢？\r\n\r\n服务器只需要与它自身的所有连接 `server.connections` 挨个发消息就是广播，所以它只是一个伪广播：我要给群里所有人发消息，但我不能在群里发，只能挨个私发。\r\n\r\n### 单节点\r\n\r\n当单节点时所有用户都能正常受到通知，流程如下\r\n\r\n![ws 单节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-single-node.jpg)\r\n\r\n这时所有用户都能收到消息通知\r\n\r\n### 多节点\r\n\r\n当多节点时，就会有部分用户无法正常受到通知，从以下流程图中可以很清楚地看到问题所在\r\n\r\n![ws 多节点时](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-multi-node.jpg)\r\n\r\n**负载到节点2的所有用户都没有收到消息通知**\r\n\r\n## 如何解决\r\n\r\n多节点服务器就会有分布式问题，解决分布式问题就找一个大家都能找到的地，比如说 `Redis`，比如说 `Kafka` 等消息件\r\n\r\n改进后流程图如下\r\n\r\n1. 需要向所有用户推送消息，请求 websocket 服务\r\n1. 负载均衡到某个节点\r\n1. 该节点向 redis/kafka 推送消息: 向所有用户推送消息通知\r\n1. 所有节点在 redis/kafka 上订阅消息\r\n1. 订阅成功后所有节点向客户端 push 消息\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n\r\n## redis PUBSUB\r\n\r\n其中有一个细节是 pub/sub 那里，redis 的 `pubsub` 较 `Kafka` 等消息中间件更为轻便，**最主要的是与ws集成的社区方案比较成熟，这点很重要**，如 Node 中的以下两个\r\n\r\n+ [graphql subscriptions - redis](https://github.com/davidyaha/graphql-redis-subscriptions)\r\n+ [socket.io-redis](https://github.com/socketio/socket.io-redis)\r\n\r\n`pubsub` 在 redis 中的命令如下\r\n\r\n+ pub: `publish channel message`\r\n+ sub: `subscribe`\r\n\r\n如果我们要订阅 `eat` 这个 `channel` 的话，图示如下\r\n\r\n![redis pubsub example](https://raw.githubusercontent.com/shfshanyue/Daily-Question/master/assets/pubsub.png)\r\n\r\n## 进一步追问\r\n\r\n面试官见我回答完问题后，又一次追问\r\n\r\n**那 websocket 如何向特定的用户组推送消息？**\r\n\r\n假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现\r\n\r\n欢迎在 Issue 中讨论: [【Q029】websocket 如何向特定用户组推送消息](https://github.com/shfshanyue/Daily-Question/issues/30)\r\n\r\n## 小结\r\n\r\n借用解决方案的图作为小结\r\n\r\n![借用 redis](https://raw.githubusercontent.com/shfshanyue/graph/master/draw/ws-redis.jpg)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA4MDYxMTU=",
    "number": 25,
    "title": "【Q024】在 postgres 中，查询时如何对 jsonb 数据格式化",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MjM0MDU0Ng==",
          "body": "使用 `jsonb_pretty` 函数，示例如下\r\n\r\n``` sql\r\n> select jsonb_pretty('{\"a\": {\"b\": 4}}'::jsonb)\r\n+----------------+\r\n| jsonb_pretty   |\r\n|----------------|\r\n| {              |\r\n|     \"a\": {     |\r\n|         \"b\": 4 |\r\n|     }          |\r\n| }              |\r\n+----------------+\r\nSELECT 1\r\nTime: 0.018s\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjA5NTU1MDI=",
    "number": 26,
    "title": "【Q025】简述 TCP socket 建立的过程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjMyNQ==",
          "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/68817970-5e11d000-06be-11ea-85ee-5d2496d14c63.png)\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEyOTc0OTU=",
    "number": 27,
    "title": "【Q026】如何对接口进行压力测试",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MjE0NQ==",
          "body": "``` bash\r\n$ ab\r\n\r\n$ wrk\r\n\r\n$ siege\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTIxNjA2NQ==",
          "body": "Jmeter",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wanming001",
            "url": "https://github.com/wanming001"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzNzA0Mjg=",
    "number": 28,
    "title": "【Q027】在前端开发中，如何获取浏览器的唯一标识",
    "body": "如何获取浏览器的唯一标识，原理是什么",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mjc4NDQ1Ng==",
          "body": "由于不同的系统显卡绘制 `canvas` 时渲染参数、抗锯齿等算法不同，因此绘制成图片数据的 `CRC` 校验也不一样。\r\n\r\n``` js\r\nfunction getCanvasFp () {\r\n  const canvas = document.getElementById('canvas')\r\n  const ctx = canvas.getContext('2d')\r\n  ctx.font = '14px Arial'\r\n  ctx.fillStyle = '#ccc'\r\n  ctx.fillText('hello, shanyue', 2, 2)\r\n  return canvas.toDataURL('image/jpeg')\r\n}\r\n```\r\n\r\n因此根据 `canvas` 可以获取浏览器指纹信息。\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n但是对于常见的需求就有成熟的解决方案，若在生产环境使用，可以使用以下库\r\n\r\n+ [fingerprintjs2](https://github.com/Valve/fingerprintjs2)\r\n\r\n它依据以下信息，获取到浏览器指纹信息\r\n\r\n1. `canvas`\r\n1. `webgl`\r\n1. `UserAgent`\r\n1. `AudioContext`\r\n1. 对新式 API 的支持程度等\r\n\r\n``` js\r\nrequestIdleCallback(function () {\r\n  Fingerprint2.get((components) => {\r\n    const values = components.map((component) => component.value)\r\n    const fp = Fingerprint2.x64hash128(values.join(''), 31)\r\n  })\r\n})\r\n```\r\n\r\n## 简答\r\n\r\n根据 `canvas` 可以获取浏览器指纹信息\r\n\r\n1. 绘制 `canvas`，获取 `base64` 的 dataurl\r\n1. 对 dataurl 这个字符串进行 `md5` 摘要计算，得到指纹信息\r\n\r\n若在生产环境使用，可以使用 [fingerprintjs2](https://github.com/Valve/fingerprintjs2)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDk5NDUyOA==",
          "body": "canvas指纹",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "minza",
            "url": "https://github.com/minza"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjEzOTk3ODA=",
    "number": 29,
    "title": "【Q028】在linux中如何获取登录的用户",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzE4MTg2OQ==",
          "body": "``` bash\r\n$ who\r\n\r\n$ last\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjE5MjExMTQ=",
    "number": 30,
    "title": "【Q029】websocket 如何向特定的用户组推送消息",
    "body": "假如一个学校有以下数据结构\r\n\r\n1. `Class`: 代表班级\r\n1. `Student`: 代表学生，每个学生都在其中一个班级\r\n\r\n那假如要向 `Class:201901` 班级的所有学生发送通知，应该如何实现",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNjQzOA==",
          "body": "在 `redis` 处维护一个对象，记录每个 group 所对应的 `connections`/`sockets`\r\n\r\n``` js\r\n{\r\n  'Class:201901': [student1Socket, student2Socket]\r\n}\r\n```\r\n\r\n当 client 刚连入 server 时，便加入某个特定的组，或者叫 room，比如 student01，刚开始连入 server，可能要加入 room：`Student:01`，`Class:201901`，`Group:10086`",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjI2MDI3MTU=",
    "number": 31,
    "title": "【Q030】linux 中如何打印所有网络接口",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mzc0MjYyOA==",
          "body": "## ifconfig\r\n\r\n`ifconfig` 是最简单最常用，但是打印信息太多了\r\n\r\n``` bash\r\n$ ifconfig\r\ncni0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1450\r\n        inet 10.244.0.1  netmask 255.255.255.0  broadcast 0.0.0.0\r\n        ether 9e:f3:9e:47:9d:55  txqueuelen 1000  (Ethernet)\r\n        RX packets 14733665  bytes 1007493238 (960.8 MiB)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 15040396  bytes 4534954611 (4.2 GiB)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n\r\ndocker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500\r\n        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255\r\n        ether 02:42:09:fe:1d:e5  txqueuelen 0  (Ethernet)\r\n        RX packets 0  bytes 0 (0.0 B)\r\n        RX errors 0  dropped 0  overruns 0  frame 0\r\n        TX packets 0  bytes 0 (0.0 B)\r\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\r\n```\r\n\r\n## netstat\r\n\r\n`netstat` 与 `ip` 也挺好用，特别是它们还可以打印路由表\r\n\r\n``` bash\r\n$ netstat -i\r\nKernel Interface table\r\nIface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg\r\ncni0             1450 14733471      0      0 0      15040202      0      0      0 BMRU\r\ndocker0          1500        0      0      0 0             0      0      0      0 BMU\r\neth0             1500 42833038      0      0 0      40961577      0      0      0 BMRU\r\nflannel.1        1450  4761436      0      0 0       4091581      0      0      0 BMRU\r\nlo              65536 376447249      0      0 0      376447249      0      0      0 LRU\r\nveth2052e2d6     1450  7358995      0      0 0       7518642      0      0      0 BMRU\r\nveth3190806e     1450  7363232      0      0 0       7510100      0      0      0 BMRU\r\n```\r\n\r\n## ip\r\n\r\n``` bash\r\n$ ip link\r\n\r\n$ ip addr\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTY3MTM=",
    "number": 32,
    "title": "【Q031】js 中如何实现 bind",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDYyNzg0NA==",
          "body": "**最简单的 `bind` 一行就可以实现，而在实际面试过程中也不会考察你太多的边界条件**\r\n\r\n``` js\r\nFunction.prototype.fakeBind = function(obj) {\r\n  return (...args) => this.apply(obj, args)\r\n}\r\n```\r\n\r\n测试一下\r\n\r\n``` js\r\nfunction f (arg) {\r\n  console.log(this.a, arg)\r\n}\r\n\r\n// output: 3, 4\r\nf.bind({ a: 3 })(4)\r\n\r\n// output: 3, 4\r\nf.fakeBind({ a: 3 })(4)\r\n```\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjc1NzYwNA==",
          "body": "那我再抄一个加强版吧嘻嘻\r\n《JavaScript权威指南》P191 ES3实现bind\r\n```\r\nif (!Function.prototype.bind) {\r\n  Function.prototype.bind = function(o /*, args */) {\r\n    var self = this, boundArgs = arguments;\r\n    return function () {\r\n      var i, args = [];\r\n      for (i = 1; i < boundArgs.length; i++) {\r\n        args.push(boundArgs[i])\r\n      }\r\n      for (i = 0; i < arguments.length; i++) {\r\n        args.push(arguments[i])\r\n     }\r\n     return self.apply(o, args)\r\n    }\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTgxNDI=",
    "number": 33,
    "title": "【Q032】js 中什么是 softbind，如何实现",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM0MTkyNDM=",
    "number": 34,
    "title": "【Q033】如何对接口进行限流",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDYzMDg2MQ==",
          "body": "一般采用漏桶算法：\r\n\r\n1. 漏桶初始为空\r\n1. API 调用是在往漏桶里注水\r\n1. 漏桶会以一定速率出水\r\n1. 水满时 API 拒绝调用\r\n\r\n![漏桶算法](https://d33wubrfki0l68.cloudfront.net/e737eb0be9176ca74d03344f082281154f90f12c/c0076/assets/img/leaky-bucket.f8cb8f08.png)\r\n\r\n可以使用 `redis` 的计数器实现\r\n\r\n1. 计数器初始为空\r\n1. API 调用计数器增加\r\n1. 给计数器设置过期时间，隔段时间清零，视为一定速率出水\r\n1. 计数器达到上限时，拒绝调用\r\n\r\n当然，这只是大致思路，这时会有两个问题要注意\r\n\r\n1. 最坏情况下的限流是额定限流速率的2倍\r\n1. 条件竞争问题\r\n\r\n不过实际实现时注意以下就好了（话说一般也是调用现成的三方库做限流...)，可以参考我以前的文章 <https://shanyue.tech/post/rate-limit/>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjg0NTU=",
    "number": 35,
    "title": "【Q034】如何实现一个 loading 动画",
    "body": "如何实现一个 loading 动画，可用 css 或 svg",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDgyMjkzMQ==",
          "body": "svg比较实在",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "chen-rongliang",
            "url": "https://github.com/chen-rongliang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDQ3MDkwMg==",
          "body": "## svg实现方案\r\n\r\n```xml\r\n<svg classname=\"loading\" viewbox=\"25 25 50 50\">\r\n  <circle cx=\"50\" cy=\"50\" r=\"25\" classname=\"path\" fill=\"none\" />\r\n</svg>\r\n```\r\n```css\r\n.loading {\r\n  width: 50px;\r\n  height: 50px;\r\n  animation: rotate 2s linear 0s infinite;\r\n}\r\n.path {\r\n  animation: dash 2s ease-in-out infinite;\r\n  stroke: #00b390;\r\n  stroke-width: 2;\r\n  stroke-dasharray: 90 150;\r\n  stroke-dashoffset: 0;\r\n  stroke-linecap: round;\r\n}\r\n\r\n@keyframes rotate {\r\n  from {\r\n    tranform: rotate(0deg);\r\n  } \r\n  to {\r\n    tranform: rotate(360deg);\r\n  }\r\n}\r\n\r\n@keyframes dash {\r\n  0% {\r\n    stroke-dasharray:  1 150;\r\n    stroke-dashoffset: 0;\r\n  } \r\n  50% {\r\n    stroke-dasharray: 90 150;\r\n    stroke-dashoffset: -40px;\r\n  }\r\n  100% {\r\n    stroke-dasharray: 90 150;\r\n    stroke-dashoffset: -120px;\r\n  }\r\n}\r\n```\r\n\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "hellojackhui",
            "url": "https://github.com/hellojackhui"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4MjkxMDQ=",
    "number": 36,
    "title": "【Q035】http 常见的状态码有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDgxODIzMw==",
          "body": "* 1XX 表示消息\r\n* 2XX 表示成功\r\n* 3XX 表示重定向\r\n* 4XX 表示客户端错误\r\n* 5XX 表示服务端错误\r\n\r\n#### 常见的状态码\r\n\r\n* 200\r\n> 最喜欢见到的状态码，表示请求成功\r\n\r\n* 301\r\n> 永久重定向\r\n\r\n* 302\r\n> 临时重定向\r\n\r\n* 304\r\n> 自上次请求，未修改的文件\r\n\r\n* 400\r\n> 错误的请求\r\n\r\n* 401\r\n> 未被授权，需要身份验证，例如token信息等等\r\n\r\n* 403\r\n> 请求被拒绝\r\n\r\n* 404\r\n> 资源缺失，接口不存在，或请求的文件不存在等等\r\n\r\n* 500\r\n> 服务器端的未知错误\r\n\r\n* 502\r\n> 网关错误\r\n\r\n* 503\r\n> 服务暂时无法使用\r\n",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "jiayankai",
            "url": "https://github.com/jiayankai"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM4Mjk0MTg=",
    "number": 37,
    "title": "【Q036】http 状态码中 301，302和307有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NDY4ODQ3NA==",
          "body": "+ 301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\r\n+ 302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\r\n+ 307，Temporary Redirect。临时重定向，在重定向时不会改变 method\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjM5NTQ1NjY=",
    "number": 38,
    "title": "【Q037】linux 有哪些发行版，你最喜欢哪一个",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NTAwNjY1Mw==",
          "body": "我最喜欢的Linux发行版是Centos，第二喜欢的是Ubuntu。Centos在服务器上很好用，Ubuntu做开发环境很好用。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangzl419",
            "url": "https://github.com/zhangzl419"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NTkzMDg0Nw==",
          "body": "> 我最喜欢的Linux发行版是Centos，第二喜欢的是Ubuntu。Centos在服务器上很好用，Ubuntu做开发环境很好用。\r\n\r\n用的人多，就好用了。（不过我装 `tmux` 和 `vim` 都需要从源码编译",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQzMDM3ODE=",
    "number": 39,
    "title": "【Q038】使用 react 实现一个通用的 message 组件",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQzNjE1ODQ=",
    "number": 40,
    "title": "【Q039】redis 的持久化方案有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTAyNjM1MQ==",
          "body": " rdb aof 主从复制+哨兵\r\nrdb是全量  aof 是增量 ",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Carrie999",
            "url": "https://github.com/Carrie999"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTQxMDczOQ==",
          "body": "两种方案\r\n\r\n+ RDB，备份数据本身。因此粒度不够细，数据完整性也不是能够很好的保证。但是简单粗暴，适合大量数据\r\n+ AOF，备份命令本身。当恢复数据时，把所有写命令执行一遍即可恢复，粒度细，完整性好。正因为是命令，所以恢复速度慢\r\n\r\n如果需要持久化时，两种方案全开。\r\n\r\nPS：一般 redis 只用到缓存功能，无重要数据，如不涉及消息队列，则持久化可以关掉",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQ4MzAwODA=",
    "number": 41,
    "title": "【Q040】k8s 由那些组件组成",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjQ5ODUyMzY=",
    "number": 42,
    "title": "【Q041】CoW 策略指什么，docker 中有哪些应用",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        },
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU3NzExNTQ=",
    "number": 43,
    "title": "【Q042】docker 中如何查看某个容器消耗的内存和CPU",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NTk4MjU5MA==",
          "body": "``` bash\r\n$ docker stats postgres\r\nCONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS\r\nadb85849e229        postgres            0.00%               3.328MiB / 1.796GiB   0.18%               0B / 0B             874GB / 2.6GB       7\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDc3NjY=",
    "number": 44,
    "title": "【Q043】如何使用命令查看一个文件有多少字符以及多少行",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MDkzNzk=",
    "number": 45,
    "title": "【Q044】如何使用vim查看文件有多少个字符以及多少行",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg3OTAxMzk2",
          "name": "vim"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjAwNDE=",
    "number": 46,
    "title": "【Q045】如何把一个 CIDR 地址转化为IP地址范围段",
    "body": "如 `172.16.0.0/27` 的IP范围是多少",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjU4MjcwODc=",
    "number": 47,
    "title": "【Q046】docker 中的网络隔离是如何实现的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NjAxODkxNQ==",
          "body": "参考: https://docs.docker.com/network/iptables/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTA3NDk=",
    "number": 48,
    "title": "【Q047】如何设计一个高并发系统",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY2MTM0MTI=",
    "number": 49,
    "title": "【Q048】如何实现一个优先级队列",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjY5MjA3MTI=",
    "number": 50,
    "title": "【Q049】什么是守护进程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzYyOQ==",
          "body": "守护进程，可以被认为是后台进程，当你把控制台关闭时，它仍然还会运行。\r\n\r\n当然 - 这只是表面，从更深层次看呢？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjcwNjMyNjg=",
    "number": 51,
    "title": "【Q050】http 状态码 502 和 504 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1NzQ3NTAyNw==",
          "body": "* 502 Bad Gateway\r\nThe server was acting as a gateway or proxy and received an invalid response from the upstream server.\r\n收到了上游响应但无法解析\r\n\r\n* 504 Gateway Timeout\r\nThe server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\r\n上游响应超时\r\n",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "sjfkai",
            "url": "https://github.com/sjfkai"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQxMDI=",
    "number": 52,
    "title": "【Q051】简述一下 graphql，它的引进有什么好处",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc0NzQ0MTc=",
    "number": 53,
    "title": "【Q052】graphql 的引进有什么风险，以及性能问题",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc1MzEwMDA=",
    "number": 54,
    "title": "【Q053】什么是对象存储，与块存储和文件存储有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc3MDM1MTU=",
    "number": 55,
    "title": "【Q054】简述TCP 的三次握手",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNTkzMw==",
          "body": "我：你在吗？\r\n他： 我在的。\r\n我： 那开始聊天吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "WenHaiYana",
            "url": "https://github.com/WenHaiYana"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTUyNTk0NA==",
          "body": "一图胜千言\r\n\r\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Tcp-handshake.svg/537px-Tcp-handshake.svg.png)\r\n\r\n三次握手之后，客户端与服务器端的两个 socket 处于 `ESTABSHED` 状态",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc3ODA5MDQ=",
    "number": 56,
    "title": "【Q055】如何在 linux 中打印所有环境变量",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTY3OTYxNA==",
          "body": "``` shell\r\n$ printenv\r\nXDG_SESSION_ID=10536\r\nHOSTNAME=shanyue\r\nTERM=xterm-256color\r\nSHELL=/bin/bash\r\nHISTSIZE=1000\r\nSSH_CLIENT=124.200.184.74 16003 22\r\nSSH_TTY=/dev/pts/0\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzYwMjU=",
    "number": 57,
    "title": "【Q056】什么是服务降级",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc4NzkzNzE=",
    "number": 58,
    "title": "【Q057】什么是熔断机制，微服务如何做熔断",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODU0OA==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjc5MzkyNjU=",
    "number": 59,
    "title": "【Q058】什么是负载均衡",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0Njk3NTU=",
    "number": 60,
    "title": "【Q059】四层负载均衡与七层负载均衡有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ5OQ==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzAzNTI=",
    "number": 61,
    "title": "【Q060】你们项目中的计划任务是如何组织的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzU1NQ==",
          "body": "TODO\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjg0NzE0MDg=",
    "number": 62,
    "title": "【Q061】如何判断两个链表是否相交",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzA5MDI0MQ==",
          "body": "只判断链表相交，好一点的方式是用双指针+哈希表。\r\n同时遍历a，b链表，如果当前a和b所在元素不在哈希表，则将元素加入哈希表。知道找到哈希表里面重复元素则算相交。时间复杂度o(max(a, b))是a，b不想交部分的较大值。空间复杂度是o(a + b)，a和b不想交部分。\r\n\r\n第二种是遍历a和b，判断尾指针是否相等。时间复杂度o(a + b)，空间复杂度o(1)。\r\n\r\n进阶问题是，找到相交链表的第一个相交点",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wython",
            "url": "https://github.com/wython"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzQxMDE=",
    "number": 63,
    "title": "【Q062】RPC 与 REST 有什么优劣",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzQ1Mw==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwMzc1Mzk=",
    "number": 64,
    "title": "【Q063】SIGINT SIGTERM SIGKILL 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM5OA==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE0MzU=",
    "number": 65,
    "title": "【Q064】如何实现服务发现 (Service Discovery)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzM0NQ==",
          "body": "TODO: k8s 的服务发现是如何实现的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkwNDE4MzI=",
    "number": 66,
    "title": "【Q065】有没有使用过 oss，对象存储相比块存储和文件存储有什么优缺点",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTcwNzIzOA==",
          "body": "OSS 兼具分布式与读取速度的平衡吧",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxMzEzOTk=",
    "number": 67,
    "title": "【Q066】如何使用 react hooks 实现 useFetch 请求数据",
    "body": "比如设计成 `useFetch` 这种形式，它的 API 应该如何设计",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0NDYyMg==",
          "body": "可以参考 [How to fetch data with React Hooks?](https://www.robinwieruch.de/react-hooks-fetch-data)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MjkxNDIxODg=",
    "number": 68,
    "title": "【Q067】react 如何使用 render prop component 请求数据",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1ODk0ODM4Mg==",
          "body": "参考: <https://www.robinwieruch.de/react-fetching-data#how-to-fetch-data-in-render-props>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjYxNzA=",
    "number": 69,
    "title": "【Q068】React Portal 有哪些使用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTY0ODY2MQ==",
          "body": "> Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.\r\n\r\n在以前， `react` 中所有的组件都会位于 `#app` 下，而使用 `Portals` 提供了一种脱离 `#app` 的组件。\r\n\r\n因此 `Portals` 适合脱离文档流(out of flow) 的组件，特别是 `position: absolute` 与 `position: fixed` 的组件。比如模态框，通知，警告，goTop 等。\r\n\r\n以下是官方一个模态框的示例，可以在以下地址中测试效果 <https://codepen.io/gaearon/pen/jGBWpE?editors=1010>\r\n\r\n\r\n``` html\r\n<html>\r\n  <body>\r\n    <div id=\"app\"></div>\r\n    <div id=\"modal\"></div>\r\n    <div id=\"gotop\"></div>\r\n    <div id=\"alert\"></div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n\r\n``` jsx\r\nconst modalRoot = document.getElementById('modal');\r\n\r\nclass Modal extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.el = document.createElement('div');\r\n  }\r\n\r\n  componentDidMount() {\r\n    modalRoot.appendChild(this.el);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    modalRoot.removeChild(this.el);\r\n  }\r\n\r\n  render() {\r\n    return ReactDOM.createPortal(\r\n      this.props.children,\r\n      this.el,\r\n    );\r\n  }\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk2MjY5OTE=",
    "number": 70,
    "title": "【Q069】什么是 virtual DOM，它的引入带了什么好处",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTYzNTY4OA==",
          "body": "数据与UI的进一步分离，这样也更有利于 SSR",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDAyNQ==",
          "body": "- 虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。\r\n-  vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。\r\n\r\n\r\n- Virtual DOM 在牺牲(牺牲很关键)部分性能的前提下，增加了可维护性，这也是很多框架的通性。\r\n实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。\r\n- 打开了函数式 UI 编程的大门。\r\n- 可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。\r\n- 可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。\r\n- 组件的高度抽象化。\r\n\r\n> 虚拟 DOM 的缺点\r\n- 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。\r\n- 虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。\r\n- 如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。\r\n",
          "star": {
            "totalCount": 6
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTQ1MjM0Mg==",
          "body": "同意楼上",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "eEmpty",
            "url": "https://github.com/eEmpty"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTU5MzUwOQ==",
          "body": "react初次render或协调后所生成的一个对象，react16前是通过组件递归遍历而来，react16是以fiber为节点构建成的单链表结构树，其作为真实dom的映射。\r\n优点：大大地提高了开发效率，解放生产力，通过计算这两棵树之间的差别来判断如何有效率的更新。\r\n缺点：初次需要构建遍历深层次的组件树，耗费性能，所以有普遍首屏渲染慢的问题。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mjk5MzIxOTA=",
    "number": 71,
    "title": "【Q070】如何用 linux 命令输出文件的特定行",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU1OTYzNTA3Mg==",
          "body": "通常使用 `sed` 命令打印特定行，如\r\n\r\n``` bash\r\n# -n: 按特定格式打印\r\n# 100p: 指打印第一百行\r\n$ sed -n 100p Readme.md\r\n```\r\n\r\n但 `sed` 打印的本领，远不止于此，除了打印特定行，还可以打印一段范围的行，如\r\n\r\n``` bash\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,120p Readme.md\r\n\r\n# 打印文件中第 100-120 行\r\n$ sed -n 100,+20p Readme.md\r\n```\r\n\r\n还有一种本办法，`head`/`tail` 的组合命令，以要输出第100行为例\r\n\r\n``` bash\r\n# 输出前100行，再通过 pipe，输出最后一行\r\n$ head -100 Readme.md | tail -1\r\n```\r\n\r\n关于 `sed` 更多的用法可以参考我的文章: [sed 命令详解及示例](https://shanyue.tech/op/linux-sed.html)\r\n\r\n## 总结\r\n\r\n两种方法\r\n\r\n1. `sed -n 100p Readme.md`\r\n1. `head -100 Readme.md | tail -1`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1Nzc4MjA=",
    "number": 72,
    "title": "【Q071】react 与 vue 数组中 key 的作用是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxOTMwODgxNQ==",
          "body": "diff算法需要比对虚拟dom的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode会首先判断key和标签名是否一致，如果一致再去判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快消耗更少",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "RunToGet",
            "url": "https://github.com/RunToGet"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODYyNDI=",
    "number": 73,
    "title": "【Q072】webpack 是用来做什么的，原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTE3MTUzNg==",
          "body": "https://juejin.im/post/5e01de37f265da33ab637daf?utm_source=gold_browser_extension",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lf75152798",
            "url": "https://github.com/lf75152798"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODgzMTQ=",
    "number": 74,
    "title": "【Q073】webpack 中的 loader 的作用是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTQ5Mw==",
          "body": "哎  lodaer 的作用就是处理单个文件的  跳到这啥都没有",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wang120140",
            "url": "https://github.com/wang120140"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg1MTY=",
    "number": 75,
    "title": "【Q074】有没有自己写过一个webpack的loader",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTM4MTUyOA==",
          "body": "我看过源码 没有写过",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wang120140",
            "url": "https://github.com/wang120140"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODg2MTQ=",
    "number": 76,
    "title": "【Q075】webpack 中plugin的作用是什么，有没有自己写过",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA1ODkyODU=",
    "number": 77,
    "title": "【Q076】如何设计一个短网址生成服务",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjMzNzQ=",
    "number": 78,
    "title": "【Q077】使用 webpack 时如何优化项目体积",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDEzMzg3Mg==",
          "body": "使用用uglyfly进行代码压缩，使用commonsChunk分离第三方代码",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "jzenzhang",
            "url": "https://github.com/jzenzhang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MjM0ODI2NQ==",
          "body": "按需加载，代码压缩，代码分割，CDN优化，gzip加速",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Michael-lzg",
            "url": "https://github.com/Michael-lzg"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjM4NTA=",
    "number": 79,
    "title": "【Q078】什么是 HMR，原理是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ0NjY=",
    "number": 80,
    "title": "【Q079】简述 http 的缓存机制",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTg5MTI5OA==",
          "body": "强缓存 协商缓存",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Owner-X",
            "url": "https://github.com/Owner-X"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ2Mzk=",
    "number": 81,
    "title": "【Q080】使用 webpack 打包时，如何更好地利用 long term cache",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjM2MjM1NQ==",
          "body": "查阅了很多前辈的资料，总结大致如下：（最后附上链接）\r\nlong term cache即“持久性缓存”\r\nUse [chunkhash] to add a content-dependent cache-buster to each file.\r\nUse compiler stats to get the file names when requiring resources in HTML.\r\nGenerate the chunk-manifest JSON and inline it into the HTML page before loading resources.\r\nEnsure that the entry point chunk containing the bootstrapping code doesn’t change its hash over time for the same set of dependencies.\r\n\r\n1.使用 [chunkhash] 为每个文件增加一个内容相关的缓存清道夫；\r\nSeparate development and production configs and use [name].js for development and [name].[chunkhash].js in production.\r\n\r\n2.使用编译统计在 HTML 中获取资源时取得文件名；[html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)\r\n\r\n3.生成 JSON 格式的模块清单文件，并在 HTML 页面加载资源之前内联进去；\r\nTo fix that, we should use [chunk-manifest-webpack-plugin](https://github.com/diurnalist/chunk-manifest-webpack-plugin) which will extract that manifest to a separate JSON file. \r\n\r\n4.保证包含启动代码的入口块不会对于同样的依赖生成不同的哈希值；（3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的——将公共库(vendor)和应用程序代码分离开来，并创建一个显式的vendor chunk以防止它频繁更改。而 webpack 4.x 则是把相关的功能包到了optimization.splitChunks中，直接使用该配置就可以实现代码分离。）\r\n\r\n[代码示例](https://github.com/okonet/webpack-long-term-cache-demo)版本：\"webpack\": \"^1.10.1\"\r\n资料来源：\r\n[webpack中文文档](https://www.webpackjs.com/guides/caching/)\r\n[Webpack Freestyle 之 Long Term Cache](https://zhuanlan.zhihu.com/p/27710902)\r\n[Long-term caching of static assets with Webpack](https://codeburst.io/long-term-caching-of-static-assets-with-webpack-1ecb139adb95#.9ro7cpngr)\r\n[用 webpack 实现持久化缓存](https://sebastianblade.com/using-webpack-to-achieve-long-term-cache/#webpack)\r\n[Webpack 的静态资源持久缓存](https://zcfy.cc/article/long-term-caching-of-static-assets-with-webpack-1204.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ3OTk=",
    "number": 82,
    "title": "【Q081】http proxy 的原理是什么",
    "body": "如 `webpack-dev-server` 可以设置 proxy，`nginx` 也可以设置",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1NTQyMA==",
          "body": "todo",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjQ5NzM=",
    "number": 83,
    "title": "【Q082】随着 http2 的发展，webpack 有没有更好的打包方案",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUyMDk=",
    "number": 84,
    "title": "【Q083】网站性能优化都有哪些点",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjUzODQ=",
    "number": 85,
    "title": "【Q084】随着 http2 的发展，前端性能优化中的哪些传统方案可以被替代",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NjA4MA==",
          "body": "1. 雪碧图\r\n1. 资源文件合并",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODg3NTkyMw==",
          "body": "我有一个不成熟的小想法：iconfont是不是可以取代雪碧图？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "oldDirver001",
            "url": "https://github.com/oldDirver001"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3Mzk3MjI3OA==",
          "body": "域名发散\r\n资源内联",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "kruzabc",
            "url": "https://github.com/kruzabc"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3Mzk4NTE0MQ==",
          "body": "@oldDirver001 可以，不过不能完全替代，比如多色",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU0NzI=",
    "number": 86,
    "title": "【Q085】http2 与 http1.1 有什么不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODkxNTczOQ==",
          "body": "1. 多路复用\r\n1. 二进制分帧\r\n1. server push\r\n1. 头部压缩\r\n\r\n可参考文章 [http2 详解](https://juejin.im/post/5b88a4f56fb9a01a0b31a67e)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjU2Nzk=",
    "number": 87,
    "title": "【Q086】webpack 中 tree shaking 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODk1MjkwNA==",
          "body": "应该是基于es6 modules的静态分析",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "coderyyx",
            "url": "https://github.com/coderyyx"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDM5MA==",
          "body": "AST",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjYxMTc=",
    "number": 88,
    "title": "【Q087】什么是 CNAME 记录和 A 记录",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NTgwNg==",
          "body": "CNAME：域名  -> 域名\r\nA：域名 -> IP",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY0Nzk=",
    "number": 89,
    "title": "【Q088】如何实现 promise.map，并限制并发数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTQyNTQ4NQ==",
          "body": "怎么实现",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "william-xue",
            "url": "https://github.com/william-xue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjY4NTc=",
    "number": 90,
    "title": "【Q089】vue 中 v-if 和 v-show 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MTkzNDA3NQ==",
          "body": "> v-show always compiles and renders everything - it simply adds the \"display: none\" style to the element. It has a higher initial load cost, but toggling is very cheap.\r\n> Incomparison, v-if is truely conditional: it is lazy, so if its initial condition is false, it won't even do anything. This can be good for initial load time. When the condition is true, v-if will then compile and render its content. Toggling a v-if block actually tearsdown everything inside it, e.g. Components inside v-if are acually destroyed and re-created when toggled, so toggling a huge v-if block can be more expensive than v-show.\r\n\r\nv-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 `display: none;` 的样式。v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。\r\n相比之下，v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于v-if下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大v-if块儿时会比v-show消耗的性能多。",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "zhaofeihao",
            "url": "https://github.com/zhaofeihao"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcwNTE=",
    "number": 91,
    "title": "【Q090】vue 中 computed 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzA1MDQzMw==",
          "body": "要讲清楚，computed原理，首先得讲vue响应式原理，因为computed的实现是基于Watcher对象的。\r\n那么vue的响应式原理是什么呢，众所周知，vue是基于Object.defineProperty实现监听的。在vue初始化数据data和computed数据过程中。会涉及到以下几个对象：\r\n1. Observe对象\r\n2. Dep对象\r\n3. Watch对象\r\nObserve对象是在data执行响应式时候调用，因为computed属性基于响应式属性，所以其不需要创建Observe对象。\r\nDep对象主要功能是做依赖收集，有个属性维护多个Watch对象，当更新时候循环调用每个Watch执行更新。\r\nWatch对象主要是用于更新，而且是收集的重点对象。\r\n\r\n这里谈到computed计算属性，首先要知道，其有两种定义方式，一种是方法，另一种是get，set属性。而且，其内部监听的对象必须是已经定义响应式的属性，比如data的属性vuex的属性。\r\n\r\nvue在创建computed属性时候，会循环所有计算属性，每一个计算属性会创建一个watch，并且在通过defineProperty定义监听，在get中，计算属性工作是做依赖收集，在set中，计算属性重要工作是重新执行计算方法，这里需要多补充一句，因为computed是懒执行，也就是说第一次初始化之后，变不会执行计算，下一次变更执行重新计算是在set中。\r\n\r\n另一个补充点是依赖收集的时机，computed收集时机和data一样，是在组件挂载前，但是其收集对象是自己属性对应的watch，而data本身所有数据对应一个watch。\r\n\r\n以下附计算属性源码验证说法：\r\n\r\n```typescript\r\n\r\nfunction initComputed (vm: Component, computed: Object) {\r\n  // $flow-disable-line\r\n  const watchers = vm._computedWatchers = Object.create(null)\r\n  // computed properties are just getters during SSR\r\n  const isSSR = isServerRendering()\r\n\r\n  for (const key in computed) {\r\n    const userDef = computed[key]\r\n    const getter = typeof userDef === 'function' ? userDef : userDef.get\r\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\r\n      warn(\r\n        `Getter is missing for computed property \"${key}\".`,\r\n        vm\r\n      )\r\n    }\r\n\r\n    if (!isSSR) {\r\n      // create internal watcher for the computed property.\r\n      watchers[key] = new Watcher(\r\n        vm,\r\n        getter || noop,\r\n        noop,\r\n        computedWatcherOptions\r\n      )\r\n    }\r\n\r\n    // component-defined computed properties are already defined on the\r\n    // component prototype. We only need to define computed properties defined\r\n    // at instantiation here.\r\n    if (!(key in vm)) {\r\n      defineComputed(vm, key, userDef)\r\n    } else if (process.env.NODE_ENV !== 'production') {\r\n      if (key in vm.$data) {\r\n        warn(`The computed property \"${key}\" is already defined in data.`, vm)\r\n      } else if (vm.$options.props && key in vm.$options.props) {\r\n        warn(`The computed property \"${key}\" is already defined as a prop.`, vm)\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n可以看到，在执行new Watcher之前，会对计算属性做判断，判断其是否为函数，如果不是则取getter。这是因为计算属性有两种定义方式。之后第二步是执行deineCoumputed。这一步只是简单的调用defineProterty我就不贴代码了。\r\n\r\n关于计算属性的getter和setter定义如下：\r\n重点关注get的懒加载部分，和Watcher的定义\r\n```typescript\r\nfunction createComputedGetter (key) {\r\n  return function computedGetter () {\r\n    const watcher = this._computedWatchers && this._computedWatchers[key]\r\n    if (watcher) {\r\n      if (watcher.dirty) {\r\n        watcher.evaluate()\r\n      }\r\n      if (Dep.target) {\r\n        watcher.depend()\r\n      }\r\n      return watcher.value\r\n    }\r\n  }\r\n}\r\n\r\nfunction createGetterInvoker(fn) {\r\n  return function computedGetter () {\r\n    return fn.call(this, this)\r\n  }\r\n}\r\n```\r\n",
          "star": {
            "totalCount": 3
          },
          "author": {
            "login": "wython",
            "url": "https://github.com/wython"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzA3MjcxNzg=",
    "number": 92,
    "title": "【Q091】vue-loader 的实现原理是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        },
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzE4MTgyMzA=",
    "number": 93,
    "title": "【Q092】react 中 ref 是干什么用的，有哪些使用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDM4ODY5MQ==",
          "body": "**取得深层次的dom的结构。进行操作；我用过的主要是对表格滚动条的操作**",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "senbochen",
            "url": "https://github.com/senbochen"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTA3NDM2NQ==",
          "body": "操作原生JS的桥梁",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzI1NzgxMzc=",
    "number": 94,
    "title": "【Q093】如何实现一个 LRU",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzI2MzUxNDc=",
    "number": 95,
    "title": "【Q094】你们的前端代码上线部署一次需要多长时间，需要人为干预吗",
    "body": "更短的部署时间，更少的人为干预，更有利于敏捷开发",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5NDkyMA==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzkyNjMxMA==",
          "body": "Jenkins+docker",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DoubleRayWang",
            "url": "https://github.com/DoubleRayWang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyMTI2OTc=",
    "number": 96,
    "title": "【Q095】k8s 中的 QoS 有哪几种类型",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjAzNzYzNw==",
          "body": "参考官方文档：[Configure Quality of Service for Pods\r\n](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/)，总结如下\r\n\r\n有三种类型 `Guaranteed`，`Burstable` 与 `BestEffort `\r\n\r\n+ `Guaranteed`\r\n    + Pod 里的每个容器都必须有内存 `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n    + Pod 里的每个容器都必须有 CPU `resources.limits` 和 `resources.requests`，而且必须是一样的\r\n+ `Burstable`\r\n    + Pod 里至少有一个容器有内存或者 CPU `resources.requests`\r\n+ `BestEffort`\r\n    + 不设置 `resources.requests` 和 `resources.limits`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjAxNzg=",
    "number": 97,
    "title": "【Q096】cron 表达式 (* 10 * * *) 会如何触发",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTA3Mg==",
          "body": "每天十点，每分钟都会执行一次",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyNjIyOTE=",
    "number": 98,
    "title": "【Q097】cron 表达式 (30 10 * * *) 会如何触发",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTIxMw==",
          "body": "每天十点半执行一次",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzMyOTUyMzQ=",
    "number": 99,
    "title": "【Q098】在 linux 中如何查看 cron 执行的情况",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjA5MTk0NA==",
          "body": "在 `centos` 中，查看日志文件\r\n\r\n``` bash\r\n$ tail -f /var/log/cron\r\nDec  5 19:30:01 8 CROND[24068]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24084]: (root) CMD (echo hello, world)\r\nDec  5 19:31:01 8 CROND[24083]: (root) CMD (echo hello)\r\nDec  5 19:32:01 8 CROND[24094]: (root) CMD (echo hello, world)\r\nDec  5 19:32:01 8 CROND[24093]: (root) CMD (echo hello)\r\nDec  5 19:33:01 8 CROND[24104]: (root) CMD (echo hello, world)\r\nDec  5 19:33:01 8 CROND[24103]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24113]: (root) CMD (echo hello)\r\nDec  5 19:34:01 8 CROND[24114]: (root) CMD (echo hello, world)\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0MDI4NzA=",
    "number": 100,
    "title": "【Q099】git 如何查看某个文件的提交历史",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjE2ODM3OA==",
          "body": "``` bash\r\ngit log -p file\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODg3NDgzMQ==",
          "body": "git log -p  filename",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "viyoung",
            "url": "https://github.com/viyoung"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
          "name": "git"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM0NDIzMzk=",
    "number": 101,
    "title": "【Q100】如何使用 react/vue 实现一个 message API",
    "body": "可以实现如下 API\r\n\r\n`message.info()`\r\n`message.success()`",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTQwMzE1MQ==",
          "body": "```\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n// info组件\r\nimport Info from 'info';\r\n// success组件\r\nimport Success from 'success';\r\n\r\nfunction createMessage(message, Com) {\r\n\r\n  let el = document.createElement('div');\r\n\r\n  document.body.appendChild(el);\r\n\r\n  const component = React.createElement(Com, {\r\n    message\r\n  });\r\n\r\n  ReactDOM.render(component, el);\r\n}\r\n\r\nconst message = {\r\n  info(message) {\r\n    return createMessage(message, Info);\r\n  },\r\n  success(message) {\r\n    return createMessage(message, Success);\r\n  },\r\n};\r\n\r\nexport default message;\r\n```\r\n主要实现思路就是创建一个div到body下，然后利用ReactDOM.render将组件渲染到这个容器下，这只是一个简单的实现，没实现关闭和多次调用",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "allan-hx",
            "url": "https://github.com/allan-hx"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5ODA1MjQ2OQ==",
          "body": "Vue 实现也是差不多，可以先写好一个 render 函数，作用是把某一HTML片段挂载到 #root 下 / 从 #root 删除该片段。然后写一个 Vue 插件，就是一个暴露了包含 install 方法的模块，install 方法中将 设置 Vue.prototype.$message = message 对象。最后使用 Vue.use 全局注册这个插件即可。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "wizzeng",
            "url": "https://github.com/wizzeng"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM3NTE1MTA=",
    "number": 102,
    "title": "【Q101】你们后端代码上线部署一次需要多长时间",
    "body": "关键在于考虑开发人员对项目部署流程的了解",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1ODE1Ng==",
          "body": "30分钟左右",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fmleing",
            "url": "https://github.com/fmleing"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDEwMDA3OA==",
          "body": "> 30分钟左右\r\n\r\n那你们部署的流程是什么呢？我觉得半个小时有点多呀",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDc1OTg1Ng==",
          "body": "> > 30分钟左右\r\n> \r\n> 那你们部署的流程是什么呢？我觉得半小时有点多呀\r\n\r\n估计和OS有关，放在测试环境上的是Linux比较快，正式环境是window就比较慢，使用的是jekins+tomcat容器",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fmleing",
            "url": "https://github.com/fmleing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM4MzM1Mzk=",
    "number": 103,
    "title": "【Q102】有没有用 npm 发布过 package，如何发布",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ3NDA=",
    "number": 104,
    "title": "【Q103】你在工作中遇到最有挑战的事情是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDA1NzQ5NQ==",
          "body": "一个人3天负责完成本来评估1周工作量的需求变更，在刚接手项目进行维护的前提下，不熟悉需要更改的业务代码实现。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "fmleing",
            "url": "https://github.com/fmleing"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5MTQ5MTk=",
    "number": 105,
    "title": "【Q104】你在工作中遇到最受挫折的事情是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzM5OTgwODg=",
    "number": 106,
    "title": "【Q105】你为什么从上家公司离职",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDA5NTk=",
    "number": 107,
    "title": "【Q106】什么是IO多路复用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMTQzNg==",
          "body": "假设你的服务器要同时处理 100 个 `socket` 连接\r\n\r\n1. 开一个线程，挨个处理。这就没法处理并发了\r\n1. 开100个线程，分别处理。这么多的线程在内核态频频进进出出也很消耗性能\r\n1. 开一个线程，去检查 `socket` 是否就绪，如果就绪则再开一个线程去处理。这就是IO多路复用了\r\n\r\n`select`、`poll`、`epoll` 是三中典型的IO多路复用的系统调用，但实际上现在 `epoll` 使用的最多。当你使用 `strace` 查看 `nodejs` 某个服务的系统调用时，将会发现 `nodejs` 就是使用了 `epoll`\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDQ5MjIwMA==",
          "body": "不会开新的线程去处理，轮训所有注册的socket，就绪就去处理",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangxiaokun",
            "url": "https://github.com/zhangxiaokun"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MDg0MzU=",
    "number": 108,
    "title": "【Q107】什么是 Basic Auth 和 Digest Auth",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0MTY5MDI=",
    "number": 109,
    "title": "【Q108】gzip 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwNjgyNg==",
          "body": "`gzip` 使用了 `LZ77` 算法与 `Huffman` 编码来压缩文件，重复度越高的文件可压缩的空间就越大。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzQ0NzcxNzA=",
    "number": 110,
    "title": "【Q109】可以对图片开启 gzip 压缩吗，为什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MjkwMzYyMw==",
          "body": "不需要开启，如果开启的话，有可能使图片变的更大。如果你注意一些网站的 img 资源时，就会发现他们都没有开启 `gzip`\r\n\r\n参考: https://webmasters.stackexchange.com/questions/8382/is-gzipping-images-worth-it-for-a-small-size-reduction-but-overhead-compressing\r\n\r\n> **Don't use gzip for image or other binary files.**\r\n>\r\n> Image file formats supported by the web, as well as videos, PDFs and other binary formats, are already compressed; using gzip on them won't provide any additional benefit, and can actually make them larger. To compress images, see Optimize images.",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NTc0OTg=",
    "number": 111,
    "title": "【Q110】http 的请求报文与响应报文的格式是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzYzNzUzMA==",
          "body": "以 `nc` 模拟 http 报文如下\r\n\r\n``` bash\r\n$ nc www.baidu.com 80\r\nGET / HTTP/1.1\r\nHost: www.baidu.com\r\n\r\nHTTP/1.1 200 OK\r\nAccept-Ranges: bytes\r\nCache-Control: no-cache\r\nConnection: Keep-Alive\r\nContent-Length: 14615\r\nContent-Type: text/html\r\nDate: Tue, 10 Dec 2019 02:48:44 GMT\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nP3p: CP=\" OTI DSP COR IVA OUR IND COM \"\r\nPragma: no-cache\r\nServer: BWS/1.1\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA285F51A1F2F8A170BB:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BIDUPSID=F0FC6B3A056DEA285F51A1F2F8A170BB; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: PSTM=1575946124; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com\r\nSet-Cookie: BAIDUID=F0FC6B3A056DEA287CB2B9422E09E30E:FG=1; max-age=31536000; expires=Wed, 09-Dec-20 02:48:44 GMT; domain=.baidu.com; path=/; version=1; comment=bd\r\nTraceid: 1575946124058431156210725656341129791126\r\nVary: Accept-Encoding\r\nX-Ua-Compatible: IE=Edge,chrome=1\r\n\r\n<!DOCTYPE html><!--STATUS OK-->\r\n........内容省略\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU0NzEwNzM=",
    "number": 112,
    "title": "【Q111】http 响应头中的 ETag 值是如何生成的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzg5NDAzNA==",
          "body": "关于 `etag` 的生成需要满足几个条件\r\n\r\n1. 当文件不会更改时，`etag` 值保持不变。所以不能单纯使用 `inode`\r\n1. 便于计算，不会特别耗 CPU。这样子 `hash` 不是特别合适\r\n1. 便于横向扩展，多个 `node` 上生成的 `etag` 值一致。这样子 `inode` 就排除了\r\n\r\n关于服务器中 `etag` 如何生成可以参考 [HTTP: Generating ETag Header](https://stackoverflow.com/questions/4533/http-generating-etag-header)\r\n\r\n**那么在 `nginx` 中的 `etag` 是如何生成的？**\r\n\r\n## nginx 中 ETag 的生成\r\n\r\n我在网上找到一些资料与源代码了解到了 `etag` 的计算方法。由 `python` 伪代码表示计算方法如下\r\n\r\n``` python\r\netag = '{:x}-{:x}'.format(header.last_modified, header.content_lenth)\r\n```\r\n\r\n源码: [ngx_http_core_modules.c](https://github.com/nginx/nginx/blob/6c3838f9ed45f5c2aa6a971a0da3cb6ffe45b61e/src/http/ngx_http_core_module.c#L1582)\r\n\r\n``` c\r\netag->value.len = ngx_sprintf(etag->value.data, \"\\\"%xT-%xO\\\"\",\r\n                                  r->headers_out.last_modified_time,\r\n                                  r->headers_out.content_length_n)\r\n                      - etag->value.data;\r\n```\r\n\r\n**总结：`nginx` 中 `etag` 由响应头的 `Last-Modified` 与 `Content-Length` 表示为十六进制组合而成。**\r\n\r\n随手在我的k8s集群里找个 `nginx` 服务测试一下\r\n\r\n``` bash\r\n$ curl --head 10.97.109.49\r\nHTTP/1.1 200 OK\r\nServer: nginx/1.16.0\r\nDate: Tue, 10 Dec 2019 06:45:24 GMT\r\nContent-Type: text/html\r\nContent-Length: 612\r\nLast-Modified: Tue, 23 Apr 2019 10:18:21 GMT\r\nConnection: keep-alive\r\nETag: \"5cbee66d-264\"\r\nAccept-Ranges: bytes\r\n```\r\n\r\n由 `etag` 计算 `Last-Modified` 与 `Content-Length`，使用 `js` 计算如下，结果相符\r\n\r\n``` js\r\n> new Date(parseInt('5cbee66d', 16) * 1000).toJSON()\r\n\"2019-04-23T10:18:21.000Z\"\r\n> parseInt('264', 16)\r\n612\r\n```\r\n\r\n## Last-Modified，ETag 与协商缓存\r\n\r\n我们知道协商缓存有两种方式\r\n\r\n+ `Last-Modified`/`if-Modified-Since`\r\n+ `ETag`/`If-None-Match`\r\n\r\n既然在 `nginx` 中 `ETag` 由 `Last-Modified` 和 `Content-Length` 组成，那它便算是一个加强版的 `Last-Modified` 了，那加强在什么地方呢？\r\n\r\n** `Last-Modified` 是由一个 `unix timestamp` 表示，则意味着它只能作用于秒级的改变**\r\n\r\n那下一个问题：[如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改](https://github.com/shfshanyue/Daily-Question/issues/113)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1Njc3NTk=",
    "number": 113,
    "title": "【Q112】如果 http 响应头中 ETag 值改变了，是否意味着文件内容一定已经更改",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2MzkyNTM2Ng==",
          "body": "不一定，由服务器中 `ETag` 的生成算法决定。详见 [#112](https://github.com/shfshanyue/Daily-Question/issues/112)\r\n\r\n比如 `nginx` 中的 `etag` 由 `last_modified` 与 `content_length` 组成，而 `last_modified` 又由 `mtime` 组成\r\n\r\n当编辑文件却未更改文件内容时，或者 `touch file`，`mtime` 也会改变，此时 `etag` 改变，但是文件内容没有更改。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Njk2NDg5NA==",
          "body": "比如 nginx 中的 etag 由 last_modified 与 content_length 组成，而 last_modified 又由 mtime 组成。\r\n\r\n\r\n那Etag是怎么解决last_modified，当编辑文件却未更改文件时间的问题？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "collins999",
            "url": "https://github.com/collins999"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1ODU2ODY=",
    "number": 114,
    "title": "【Q113】如何看待 toB 与 toC",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU1OTAyOTc=",
    "number": 115,
    "title": "【Q114】如何查看一个文件的 inode number",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk3ODc1Nw==",
          "body": "可以使用 `ls` 或者 `stat`\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n\r\n$ ls -i hello.txt\r\n917526 hello.txt\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NTA0MDI=",
    "number": 116,
    "title": "【Q115】文件系统中 mtime 和 ctime 指什么，都有什么不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk4MzQ3Nw==",
          "body": "在 `linux` 中，\r\n\r\n+ `mtime`：`modified time` 指文件内容改变的时间戳\r\n+ `ctime`：`change time` 指文件属性改变的时间戳，属性包括 `mtime`。而在 windows 上，它表示的是 `creation time`\r\n\r\n所以 `ctime` 会比 `mtime` 要大一些，使用 `stat` 查看文件属性如下\r\n\r\n``` bash\r\n$ stat hello.txt\r\n  File: ‘hello.txt’\r\n  Size: 30              Blocks: 8          IO Block: 4096   regular file\r\nDevice: fd01h/64769d    Inode: 917526      Links: 1\r\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\r\nAccess: 2019-12-10 16:15:55.253325208 +0800\r\nModify: 2019-12-10 16:15:52.740653330 +0800\r\nChange: 2019-12-10 16:15:52.742653069 +0800\r\n Birth: -\r\n```\r\n\r\n而 http 服务选择 `Last_Modified` 时一般会选择 `mtime`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2NzAxMjE=",
    "number": 117,
    "title": "【Q116】http 服务中静态文件的 Last-Modified 是根据什么生成的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk5NzU5OA==",
          "body": "一般会选文件的 `mtime`，表示文件内容的修改时间\r\n\r\n`nginx` 也是这样处理的，源码见: [ngx_http_static_module.c](https://github.com/nginx/nginx/blob/4bf4650f2f10f7bbacfe7a33da744f18951d416d/src/http/modules/ngx_http_static_module.c#L217)\r\n\r\n``` c\r\n    r->headers_out.status = NGX_HTTP_OK;\r\n    r->headers_out.content_length_n = of.size;\r\n    r->headers_out.last_modified_time = of.mtime;\r\n```\r\n\r\n关于为什么使用 `mtime` 而非 `ctime`，可以参考 [#116](https://github.com/shfshanyue/Daily-Question/issues/117)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU2ODYxNjY=",
    "number": 118,
    "title": "【Q117】既然 http 是无状态协议，那它是如何保持登录状态",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDAwMzA2Nw==",
          "body": "通过 cookie 或者 Authorization header 来传递凭证，在服务端进行认证",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODY0ODM=",
    "number": 119,
    "title": "【Q118】有没有读过 koa 的源码，什么是洋葱模型呢",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU3ODcwMDU=",
    "number": 120,
    "title": "【Q119】https 是如何保证报文安全的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODM4MDY4MA==",
          "body": "https主要解决三个安全问题：\r\n1. 内容隐私\r\n2. 防篡改\r\n3. 确认对方身份\r\n\r\nhttps并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有秘钥，最后通过该秘钥对称加密传输数据。还有验证证书的正确性。\r\n证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "wython",
            "url": "https://github.com/wython"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTAyNTc=",
    "number": 121,
    "title": "【Q120】TCP 是如何保证可靠性的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDY3Nw==",
          "body": "ACK",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzU4MTk4MDM=",
    "number": 122,
    "title": "【Q121】我们如何从 http 的报文中得知该服务使用的技术栈",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDEwMTEwMw==",
          "body": "一般有两个 response header，有时服务端为了隐蔽自己真实的技术栈会隐蔽这两个字段\r\n\r\n+ `X-Powerd-By`\r\n+ `Server`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzYxODgyMjQ=",
    "number": 123,
    "title": "【Q122】在发送 http 请求报文时，Host 是必要的吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDgwODY1NA==",
          "body": "是有必要的，因为我们不知道会途径会不会有代理出现， 如果直接到达服务器的话，服务器是可以通过路径知道资源在哪，但是如果通过代理的话，代理无法得知具体服务器是什么地址",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Gloomysunday28",
            "url": "https://github.com/Gloomysunday28"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY3MzY1NTI=",
    "number": 124,
    "title": "【Q123】如何监控文件的变动",
    "body": "当一个文件或者一个目录下的文件有所变动时能够监控到。\r\n\r\n如一些前端和后端项目在开发环境下会根据项目目录变动而重启或者重新编译",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDkwNDYwMQ==",
          "body": "1. 在 node 中调用 API `fs.watch`\r\n1. 在 linux 中原理是 `inotify`，macos 中原理是 `FSEvents`，windows 中原理是 ` ReadDirectoryChangesW`\r\n1. 由于内核对文件监控更加细粒度，更加敏感，当每次修改文件时可能触发内核多次调用，需要防抖\r\n1. 注意软链接，读写权限等文件系统属性\r\n\r\n可参考文章 [How to Watch for Files Changes in Node.js](https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/) 及 [精读《如何利用 Nodejs 监听文件夹》](https://github.com/dt-fe/weekly/blob/v2/059.%E7%B2%BE%E8%AF%BB%E3%80%8A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20Nodejs%20%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%8B.md)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTAzMzA5NA==",
          "body": "我不太清楚问这个的目的，是 fs.watch 吧？若要问的深一点底层怎么做的监听，我就不会了。贴一下答案？",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "everlose",
            "url": "https://github.com/everlose"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTA1NDQzOQ==",
          "body": "@everlose 简单的总结了以下，见楼上",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MDc0NDQ=",
    "number": 125,
    "title": "【Q124】如何保证内网服务的安全性",
    "body": "如 `gitlab CE` 经常暴露出重大漏洞，而它也只需要在公司内部使用。部署 `gitlab` 时我们如何保证它的安全性",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDk2MTA5Nw==",
          "body": "basic auth，digest auth，ip whitelist，vpn",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzY4MzU3MzA=",
    "number": 126,
    "title": "【Q125】docker 中如何为每个容器的 cpu/memory 设限，原理是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc0MTgzNzQ=",
    "number": 127,
    "title": "【Q126】localhost:3000 与 localhost:5000 的 cookie 信息是否共享",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1Mjk1Mg==",
          "body": "共享",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTM1NDgxNg==",
          "body": "根据同源策略，cookie是区分端口的，但是浏览器实现来说，“cookie区分域，而不区分端口，也就是说，同一个ip下的多个端口下的cookie是共享的！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zhangwen9229",
            "url": "https://github.com/zhangwen9229"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc1NDM2MzA=",
    "number": 128,
    "title": "【Q127】vpn 的原理是什么",
    "body": "当在公司工作时经常需要 vpn 用以连接公司内网，其原理是什么",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODMzMjQ2NQ==",
          "body": "正向代理",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "xinlanlan",
            "url": "https://github.com/xinlanlan"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc4ODYyMzI=",
    "number": 129,
    "title": "【Q128】构建镜像时，那几个指令会增加镜像层数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTY5Njk1Nw==",
          "body": "`RUN`，`ADD`，`COPY`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzc5MDczNTY=",
    "number": 130,
    "title": "【Q129】shell 中 ${} 与 $() 各是什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTcxMjkwOQ==",
          "body": "+ `${}` 变量\r\n+ `$()` 命令",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjc4MDU=",
    "number": 131,
    "title": "【Q130】docker 如何隔离容器与宿主机的时间",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMjkzODM=",
    "number": 132,
    "title": "【Q131】在 docker 的容器中，如何访问宿主机的 localhost",
    "body": "如在宿主机有一个 `mysql` 数据库，在容器中，如何连接数据库",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgxMzEzMjg=",
    "number": 133,
    "title": "【Q132】如何在 docker 中运行 docker",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzgyNzc2Nzg=",
    "number": 134,
    "title": "【Q133】http 响应头中如果 content-type 为 application/octet-stream，则代表什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDg3MA==",
          "body": "代表二进制流，一般用以下载文件",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1MzkxMDc4ODk=",
    "number": 135,
    "title": "【Q134】ssh 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1MjE1ODM3OQ==",
          "body": "搬运 [图解SSH原理](https://www.jianshu.com/p/33461b619d53)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hedongxiaoshimei",
            "url": "https://github.com/hedongxiaoshimei"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Mzk0MjUwMzk=",
    "number": 136,
    "title": "【Q135】负载均衡有哪几种方式，它们的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2Njg0NzUzOQ==",
          "body": "TODO",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDAxMzI2OTY=",
    "number": 137,
    "title": "【Q136】http 向 https 做重定向应该使用哪个状态码",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMTc1Nw==",
          "body": "一般用作 `301` 的较为多，但是也有使用 `302`，如果开启了 `HSTS` 则会使用 `307`\r\n\r\n如知乎使用了 302，淘宝使用了 301\r\n\r\n``` bash\r\n$ curl --head www.zhihu.com\r\nHTTP/1.1 302 Found\r\nDate: Tue, 24 Dec 2019 00:13:54 GMT\r\nContent-Length: 22\r\nConnection: keep-alive\r\nServer: NWS_TCloud_IPV6\r\nLocation: https://www.zhihu.com/\r\nX-NWS-LOG-UUID: 0e28d9a1-6aeb-42cd-9f6b-00bd6cf11500\r\n\r\n$ curl --head www.taobao.com\r\nHTTP/1.1 301 Moved Permanently\r\nServer: Tengine\r\nDate: Tue, 24 Dec 2019 00:13:58 GMT\r\nContent-Type: text/html\r\nContent-Length: 278\r\nConnection: keep-alive\r\nLocation: https://www.taobao.com/\r\nVia: cache20.cn1480[,0]\r\nTiming-Allow-Origin: *\r\nEagleId: 6f3f38a815771464380412555e\r\n\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA4MTY1NDQ=",
    "number": 138,
    "title": "【Q137】js 代码压缩的原理是什么",
    "body": "我们知道 `javascript` 代码经压缩 (uglify) 后，可以使体积变得更小，那它代码压缩的原理是什么。\r\n\r\n如果你来做这么一个功能的话，你会怎么去压缩一段 `js` 代码的体积",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NzgxOTE4Ng==",
          "body": "https://github.com/mishoo/UglifyJS2",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzM5NDk1Nw==",
          "body": "@shfshanyue 问的是原理，你贴UglifyJS2的地址干嘛",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "libin1991",
            "url": "https://github.com/libin1991"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTA0MjQ2Ng==",
          "body": "uglify 包里有 ast.js 所以它一定是生成了抽象语法树\r\n接着遍历语法树并作出优化，像是替换语法树中的变量，变成a，b，c那样的看不出意义的变量名。还有把 if/else 合并成三元运算符等。\r\n最后输出代码的时候，全都输出成一行。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "everlose",
            "url": "https://github.com/everlose"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5NjUwNTk=",
    "number": 139,
    "title": "【Q138】一个守护进程的创建步骤是什么，如何用 C 语言创建",
    "body": "#50 ",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5NzU5MDg=",
    "number": 140,
    "title": "【Q139】在 Node 应用中如何利用多核心CPU的优势",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyNDQyMQ==",
          "body": "使用 `cluster` 模块\r\n\r\n[Node 中 cluster 的原理是什么](https://github.com/shfshanyue/Daily-Question/issues/141)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDA5ODQ0NDI=",
    "number": 141,
    "title": "【Q140】Node 中 cluster 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2NzkyMzY1NA==",
          "body": "1. `fork` 子进程\r\n1. `Load Balance`\r\n1. 多进程共享端口\r\n\r\n## 相关文章\r\n\r\n+ [Node 官方文档: cluster](https://nodejs.org/api/cluster.html)\r\n+ [深入浅出 node cluster](https://juejin.im/post/5c87760fe51d4507534c88e5)\r\n+ [Node.js进阶：cluster模块深入剖析](https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDEzMjg1MTI=",
    "number": 142,
    "title": "【Q141】http 响应头中的 Date 与 Last-Modified 有什么不同，网站部署时需要注意什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODE4MjMzNw==",
          "body": "+ `Date`: 报文在源服务器的产生时间，由此可查看报文已缓存了多久时间\r\n+ `Last-Modified`: 源服务器上资源的上次修改时间\r\n\r\n`LM-Factor` 与它俩有关。\r\n\r\n简而言之，一个静态资源没有设置 `Cache-Control` 时会以这两个响应头来设置强制缓存时间：`(Date - LastModified) * n`，而非直接进行协商缓存。在涉及到 CDN 时，表现更为明显，体现在更新代码部署后，界面没有更新。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE0MjcyMzg=",
    "number": 143,
    "title": "【Q142】react hooks 中如何模拟 componentDidMount",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODg1MDAwNw==",
          "body": "在 `useEffect`，把第二个参数即依赖的状态，设置为 `[]`\r\n \r\n``` js\r\nuseEffect(callback, [])\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE1NzE2NTk=",
    "number": 144,
    "title": "【Q143】docker-compose 部署 docker 时，如何把宿主机的环境变量注入到容器中",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjg1NjEyMDI0",
          "name": "docker"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDE5Mzc1MTU=",
    "number": 145,
    "title": "【Q144】http 1.1 中的 keep-alive 有什么作用",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODYxMDUxMw==",
          "body": "在 `http 1.1` 中，在响应头中设置 `keep-alive` 可以在一个 TCP 连接上发送多个 http 请求\r\n\r\n1. 避免了重开 TCP 连接的开销\r\n1. 避免了刷新时重新建立 SSL 连接的开销\r\n1. 避免了QPS过大时，服务器的连接数过大\r\n\r\n在服务器端使用响应头开启 `keep-alive`\r\n\r\n``` bash\r\nConnection: Keep-Alive\r\nKeep-Alive: timeout=5, max=1000\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIxMzQ2MTU=",
    "number": 146,
    "title": "【Q145】如何判断端口是否可达",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODc1MjAzMA==",
          "body": "使用 `nc`，`-z` 指测试接口连通性\r\n\r\n``` bash\r\nnc -vz localhost 443\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDIyMjk1OTE=",
    "number": 147,
    "title": "【Q146】如果使用 SSR，可以在 created/componentWillMount 中访问 localStorage 吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2ODgxNzY1Mw==",
          "body": "不可以，created/componentWillMount 时，还未挂载，代码仍然在服务器中执行，此时没有浏览器环境，因此此时访问 localStorage 将会报错",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwMDQxMzg3OQ==",
          "body": "我试了 可以啊 这是时候只是找不到实体DOM 但是具备js的执行环境了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "thunderqin",
            "url": "https://github.com/thunderqin"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI1NDY2MzM=",
    "number": 148,
    "title": "【Q147】当在浏览器中看到某资源使用了 http2 后，使用 curl 为什么看到的仍是 http 1.1",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTM4MzY4Mg==",
          "body": "当前 curl 的版本及支持的协议以及功能特性没有支持 HTTP2",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "vczx1994",
            "url": "https://github.com/vczx1994"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3ODkxODU=",
    "number": 149,
    "title": "【Q148】关于 JSON，以下代码输出什么",
    "body": "``` js\r\nconst obj = {\r\n  a: 3,\r\n  b: 4,\r\n  c: null,\r\n  d: undefined,\r\n  get e () {}\r\n}\r\n\r\nconsole.log(JSON.stringify(obj))\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTIxNzAyNg==",
          "body": "> ``` js\r\n> const obj = {\r\n>   a: 3,\r\n>   b: 4,\r\n>   c: null,\r\n>   d: undefined,\r\n>   get e () {}\r\n> }\r\n> ```\r\n> \r\n> console.log(JSON.stringify(obj))\r\n>\r\n> 输出什么？\r\n\r\n``` js\r\n{\"a\":3,\"b\":4,\"c\":null}\r\n```\r\n\r\n对其中的 `undefined`，`function` 将在 `JSON.stringify` 时会忽略掉",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTIyNTAwNQ==",
          "body": "666",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "qiushangzhe",
            "url": "https://github.com/qiushangzhe"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDI3OTEzMzg=",
    "number": 150,
    "title": "【Q149】什么是队首阻塞，如何解决，原理如何",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDMxMzgwMDQ=",
    "number": 151,
    "title": "【Q150】redis 中 zset 是什么，用作什么应用场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTQxMjcyNQ==",
          "body": "`SortedSet`，有序集合，一般可以有两种用途\r\n\r\n1. 排行榜，TOP N 之类\r\n1. 优先级消息队列",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQxMDM=",
    "number": 152,
    "title": "【Q151】react hooks 如何替代或部分替代 redux 功能",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTcwNDI4MQ==",
          "body": "我们把全局store分为两块\r\n\r\n1. 从服务器端来，如各种 `model`，此时可以使用 `swr` 直接替代。或者封装一个 `useModel`，如 `useUser`，`usePermission`\r\n1. 客户端全局 store，此时可以使用 `useReducer` 和 `useContext` 来替代",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMzE2Nw==",
          "body": "useReducer+useContext",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDM3MDQ5NTA=",
    "number": 153,
    "title": "【Q152】如何实现一个 react hook，你有没有自己写过一个",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTcwMzM1Nw==",
          "body": "可以参考官方文档 <https://reactjs.org/docs/hooks-custom.html>\r\n\r\n自定义一个 `hook` 仅仅是一个以 `use` 打头，组合 `useState` 和 `useEffect` 或者其它 `hooks` 的一个普通函数",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMzQzNg==",
          "body": "各种优秀实现=》https://github.com/streamich/react-use",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDU0MjYxOQ==",
          "body": "> 各种优秀实现=》https://github.com/streamich/react-use\r\n\r\n这个厉害！",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0MzI2MjM=",
    "number": 154,
    "title": "【Q153】权限设计中的 RABC 是指什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0NTk0MjA=",
    "number": 155,
    "title": "【Q154】在 react/vue 中数组是否可以以在数组中的次序为 key",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDUzMjIwMg==",
          "body": "不可，key应为唯一标示，在数组变更时插入或删除后，index无法确保始终指向对应的序列",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "into-piece",
            "url": "https://github.com/into-piece"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        },
        {
          "id": "MDU6TGFiZWwxNjU4MzU0NDc5",
          "name": "vue"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ0ODE3NjM=",
    "number": 156,
    "title": "【Q155】当服务升级或者回退时，如何保证流量平滑切换",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NDE5Mjc=",
    "number": 157,
    "title": "【Q156】如何进行代码质量检测",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDE4Nzc0NA==",
          "body": "圈复杂度(Cyclomatic complexity)描写了代码的复杂度，可以理解为覆盖代码所有场景所需要的最少测试用例数量。CC 越高，代码则越不好维护\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDQ1NTcxMDg=",
    "number": 158,
    "title": "【Q157】如何管理生产环境多个数据库的配置，如何快速连接",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUyODExMzI=",
    "number": 159,
    "title": "【Q158】数据库 postgres 与 mysql 相比有哪些优劣",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzQ2NDc=",
    "number": 160,
    "title": "【Q159】什么是 CSRF 攻击",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzgyMTQyOA==",
          "body": "跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\r\n\r\n来源：[维基百科](https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DoubleRayWang",
            "url": "https://github.com/DoubleRayWang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNDI=",
    "number": 161,
    "title": "【Q160】如何设置一个 cookie",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjgxMjk3MQ==",
          "body": "HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。\r\n\r\n服务端是通过setCookie的响应头来设置cookie的，要设置多个cookie时，得多写几个setCookie。服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个Set-Cookie字段。\r\n\r\n前端使用document.cookie属性来读写当前网页的 Cookie。写入的时候，Cookie 的值必须写成key=value的形式。\r\n\r\nCookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。\r\n参考资料：\r\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)\r\n[把cookie聊清楚](https://juejin.im/post/59d1f59bf265da06700b0934)\r\n[阮一峰JavaScript教程](https://javascript.ruanyifeng.com/bom/cookie.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDUzNzUwNjU=",
    "number": 162,
    "title": "【Q161】如何删除一个 cookie",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU0MTk0OTE=",
    "number": 163,
    "title": "【Q162】如何禁止服务器被 ping",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDU3MDExMDM=",
    "number": 164,
    "title": "【Q163】如何创建一个线程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MjUzNTY3NQ==",
          "body": "创建一个最简单的线程\r\n\r\n``` c\r\n#include <pthread.h>\r\n#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nvoid *thread_function(void *arg) {\r\n  printf(\"hello, world\\n\");\r\n  sleep(10);\r\n}\r\n\r\nint main() {\r\n  pthread_t thread;\r\n\r\n  pthread_create(&thread, NULL, thread_function, NULL);\r\n  pthread_join(thread, NULL);\r\n}\r\n```\r\n\r\n执行它\r\n\r\n``` bash\r\n$ gcc thread.c -std=c99 -lpthread && ./a.out\r\nhello, world\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc0Mzk3ODI=",
    "number": 165,
    "title": "【Q164】React 中 fiber 是用来做什么的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDczODQ3NA==",
          "body": "因为JavaScript单线程的特点，每个同步任务不能耗时太长，不然就会让程序不会对其他输入作出相应，React的更新过程就是犯了这个禁忌，而React Fiber就是要改变现状。\r\n而可以通过分片来破解JavaScript中同步操作时间过长的问题。\r\n\r\n把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。\r\n\r\nReact Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。\r\n\r\n维护每一个分片的数据结构，就是Fiber。",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "yuzeyang97",
            "url": "https://github.com/yuzeyang97"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc1MTMwODM=",
    "number": 166,
    "title": "【Q165】什么是公有云，私有云，混合云以及多重云",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDc1MzA5OTA=",
    "number": 167,
    "title": "【Q166】在C语言中，void * 是什么意思",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg0MTM1MTQ=",
    "number": 168,
    "title": "【Q167】每个指针所占的存储空间是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzMwNDg5MQ==",
          "body": "与字长有关。如果是64位系统，则占八个字节，32位系统，则占四个字节。可以用 `sizeof` 测试\r\n\r\n``` c\r\n#include <stdio.h>\r\n\r\nint main() {\r\n  int *p;\r\n\r\n  printf(\"size: %d\", sizeof(p));\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MTA3OTM=",
    "number": 169,
    "title": "【Q168】在 js 中如何把类数组转化为数组",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzY3MTY0Mg==",
          "body": "首先，什么是类数组(Array Like)？\r\n\r\n**一个简单的定义，如果一个对象有 `length` 属性值，则它就是类数组**\r\n\r\n那常见的类数组有哪些呢？\r\n\r\n这在 DOM 中甚为常见，如各种元素检索 API 返回的都是类数组，如 `document.getElementsByTagName`，`document.querySelectorAll` 等等。除了 DOM API 中，常见的 `function` 中的 `arguments` 也是类数组\r\n\r\n那如何把类数组转化为数组呢？这是类数组操作时一个典型的场景，也是一个典型的面试题\r\n\r\n以下我们将以 `{ length: 3 }` 来指代类数组，来作为演示\r\n\r\n<!--more-->\r\n\r\n## ES6+\r\n\r\n`ES6` 中有现成的 API：`Array.from`，极为简单\r\n\r\n``` js\r\n// [undefined, undefined, undefined]\r\nArray.from({ length: 3 })\r\n```\r\n\r\n除了 `Array.from` 还有更简单的运算符 `...` 扩展运算符，不过它只能作用于 `iterable` 对象，即拥有 `Symbol(Symbol.iterator)` 属性值\r\n\r\n拥有 `Symbol(Symbol.iterator)` 属性值，意味着可以使用 `for of` 来循环迭代\r\n\r\n``` js\r\n// 适用于 iterable 对象\r\n[...document.querySelectorAll('div')]\r\n```\r\n\r\n但是严格意义上来说，它不能把类数组转化为数组，如 `{ length: 3 }`。它将会抛出异常\r\n\r\n``` js\r\n// Uncaught TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator))\r\n[...{length: 3}]\r\n```\r\n\r\n## ES5\r\n\r\n在此之前，我们先不使用 `{ length: 3 }`，使用以下数据来代表类数组\r\n\r\n``` js\r\nconst arrayLike = {\r\n  0: 3,\r\n  1: 4,\r\n  2: 5,\r\n  length: 3\r\n}\r\n```\r\n\r\n在 `ES5` 中可以借用 `Array API` 通过 `call/apply` 改变 `this` 或者 `arguments` 来完成转化。\r\n\r\n最常见的转换是 `Array.prototype.slice`\r\n\r\n``` js\r\nArray.prototype.slice.call(arrayLike)\r\n```\r\n\r\n**当然由于借用 `Array API`，一切以数组为输入，并以数组为输出的 API 都可以来做数组转换，如**\r\n\r\n+ `Array` (借用 arguments)\r\n+ `Array.prototype.concat` (借用 arguments)\r\n+ `Array.prototype.slice` (借用 this)\r\n+ `Array.prototype.map` (借用 this)\r\n+ `Array.prototype.filter` (借用 this)\r\n\r\n``` js\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\nArray.prototype.slice.call(arrayLike)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n此时一切正常，但是忘了一个特例，稀疏数组。在此之前，先做一个题，以下代码输出多少\r\n\r\n``` js\r\n// 该代码输出多少\r\nArray(100).map(x => 1)\r\n```\r\n\r\n> 参考 [Array(100).map(x => 1) 结果是多少](https://github.com/shfshanyue/Daily-Question/issues/170)\r\n\r\n## 稀疏数组 (sparse array)\r\n\r\n使用 `Array(n)` 将会创建一个稀疏数组，为了节省空间，稀疏数组内含非真实元素，在控制台上将以 `empty` 显示，如下所示\r\n\r\n`[,,,]` 与 `Array(3)` 都将返回稀疏数组\r\n\r\n``` js\r\n> [,,,]\r\n[empty × 3]\r\n> Array(3)\r\n[empty × 3]\r\n```\r\n\r\n当类数组为 `{ length: 3 }` 时，一切将类数组做为 `this` 的方法将都返回稀疏数组，而将类数组做为 `arguments` 的方法将都返回密集数组\r\n\r\n## 总结\r\n\r\n由上总结，把类数组转化成数组最靠谱的方式是以下三个\r\n\r\n``` js\r\nArray.from(arrayLike)\r\nArray.apply(null, arrayLike)\r\nArray.prototype.concat.apply([], arrayLike)\r\n```\r\n\r\n以下几种方式需要考虑稀疏数组的转化\r\n\r\n``` js\r\nArray.prototype.filter.call(divs, x => 1)\r\nArray.prototype.map.call(arrayLike, x => x)\r\nArray.prototype.filter.call(arrayLike, x => 1)\r\n```\r\n\r\n以下方法要注意是否是 `iterable object`\r\n\r\n``` js\r\n[...arrayLike]\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg3MzAxNjc=",
    "number": 170,
    "title": "【Q169】Array(100).map(x => 1) 结果是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzUyNzgyOA==",
          "body": "`Array(100)` 将会创建一个稀疏数组 (sparse array)，即不存在真实元素，节省内存空间。在控制台上显示为 `[empty]`\r\n\r\n``` js\r\n// [empty × 100]\r\nArray(100)\r\n```\r\n\r\n正因为没有元素，所以它也不会有 `map` 操作，所以 `Array(100).map(x => 1)` 仍然返回为 `[empty]`\r\n\r\n**那如何生成100个元素为1的数组呢？**\r\n\r\n可以使用 `Array.from`\r\n\r\n``` js\r\nArray.from(Array(100), x => 1)\r\n```\r\n\r\n而在 `ES5` 中借用 `apply`\r\n\r\n``` js\r\nArray.apply(null, Array(100)).map(x => 1)\r\n```\r\n\r\n根据楼下提示，再添加一个 `fill`\r\n\r\n``` js\r\nArray(100).fill(1)\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3Mzk2MTEwNQ==",
          "body": "> 那如何生成100个元素为1的数组呢？\r\n\r\n```ts\r\nArray(100).fill(1)\r\n```",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "Chersquwn",
            "url": "https://github.com/Chersquwn"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDg4MzUzMDY=",
    "number": 171,
    "title": "【Q170】什么是文件描述符 (file descriptor)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3MzU5OTE0MA==",
          "body": "`fd` 在内核中通常表示为非负整数，当进程新建或者打开文件时，内核将会返回一个文件描述符，使用它可以用来读写文件。\r\n\r\n另外，新建 `socket` 时也会产生一个文件描述符。\r\n\r\n另外，有三个特殊的文件描述符，用以表示标准输入，标准输出及标准错误\r\n\r\n+ `STDIN_FILENO`: 0\r\n+ `STDOUT_FILENO`: 1\r\n+ `STDERR_FILENO`: 2",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDkzNTkzNjc=",
    "number": 172,
    "title": "【Q171】在服务器内如何得知自己的公网IP",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NDAyMzI2NQ==",
          "body": "有现成的公网IP服务提供，根据 TCP 连接获得真实 IP 地址\r\n\r\n``` bash\r\n$ curl ifconfig.me\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0MTQ3MjE=",
    "number": 173,
    "title": "【Q172】C语言中 printf 与 puts 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NDA2NjU1Ng==",
          "body": "```c\r\n// 支持各种格式\r\nint printf(const char *__restrict__ __format, ...);\r\n\r\n// 只支持字符串输出到 stdout，适用于只有字符串时\r\nint puts(const char *__s);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk0NTk5NDI=",
    "number": 174,
    "title": "【Q173】简述 UDP socket 建立的过程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NDA5OTY3MQ==",
          "body": "一图胜千言\r\n\r\n![image](https://user-images.githubusercontent.com/13389461/72334798-e3365700-36f8-11ea-9bd8-1bfd59118c01.png)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUwMzc=",
    "number": 175,
    "title": "【Q174】TCP 三次握手发生在 socket 建立的哪一步",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1MjUzNDA=",
    "number": 176,
    "title": "【Q175】如何使用 css 写一个魔方",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk1NzgyNjA=",
    "number": 177,
    "title": "【Q176】如何在数组中找出三个数之和为N",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NDk2MjY5NjQ=",
    "number": 178,
    "title": "【Q177】如何在 url 中传递数组",
    "body": "可以参考 [arrays in query params](https://medium.com/raml-api/arrays-in-query-params-33189628fa68)",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAwMjQ0NjM=",
    "number": 179,
    "title": "【Q178】如何使用 css 写一个有 3D 效果的立方体",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjQ0NDE0Mw==",
          "body": "`<div class=\"warp\">\r\n\t<div class=\"box box1\">1</div>\r\n    <div class=\"box box2\">2</div>\r\n    <div class=\"box box3\">3</div>\r\n    <div class=\"box box4\">4</div>\r\n    <div class=\"box box5\">5</div>\r\n    <div class=\"box box6\">6</div>\r\n</div>`\r\n`* {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n}\r\n\r\nbody {\r\n\tperspective: none;\r\n\tperspective-origin: 50% 50%;\r\n}\r\n\r\n.warp {\r\n\twidth: 500px;\r\n\theight: 500px;\r\n\tmargin: 100px auto;\r\n\t\r\n\tposition: relative;\r\n\t\r\n\ttransform-style: preserve-3d;\r\n\t\r\n\ttransform: rotateX(45deg) rotateY(45deg);\r\n\t\r\n\tanimation: play 5s linear infinite;\r\n}\r\n\r\n.box {\r\n\twidth: 200px;\r\n\theight: 200px;\r\n\tborder: 2px solid #ccc;\r\n\t\r\n\ttext-align: center;\r\n\tline-height: 200px;\r\n\tfont-size: 150px;\r\n\tfont-weight: bold;\r\n\tcolor: #fff;\r\n\t\r\n\tposition: absolute;\r\n\ttop: 150px;\r\n\tleft: 150px;\r\n}\r\n\r\n.box1 {\r\n\tbackground: rgba(135,135,135,.3);\r\n\ttransform: rotateY(90deg) translateZ(100px);\r\n}\r\n\r\n.box2 {\r\n\tbackground: rgba(135,0,255,.3);\r\n\ttransform: rotateY(90deg) translateZ(-100px);\r\n}\r\n\r\n.box3 {\r\n\tbackground: rgba(255,125,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(-100px);\r\n}\r\n\r\n.box4 {\r\n\tbackground: rgba(125,255,125,.3);\r\n\ttransform: rotateX(90deg) translateZ(100px);\r\n}\r\n\r\n.box5 {\r\n\tbackground: rgba(30,150,189,.3);\r\n\ttransform: translateZ(100px);\r\n}\r\n\r\n.box6 {\r\n\tbackground: rgba(169,150,189,.3);\r\n\ttransform: translateZ(-100px);\r\n}\r\n\r\n@keyframes play {\r\n\tfrom{ transform: rotateX(0) rotateY(0) rotateZ(0);}\r\n\tto {transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg);}\r\n}`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "lihan1k",
            "url": "https://github.com/lihan1k"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAxNzM3ODM=",
    "number": 180,
    "title": "【Q179】ssh 如何设置 IP whiteList",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTAyNDUxMTk=",
    "number": 181,
    "title": "【Q180】当执行 SQL 语句 select * from user where id = 1 时发什么了什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTA4NjI4NDc=",
    "number": 182,
    "title": "【Q181】如何用一行代码实现 compose 函数",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyNzc0MDg=",
    "number": 183,
    "title": "【Q182】简述 TCP 的四次挥手，三次挥手可以吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTU3MjAwNQ==",
          "body": "第一次挥手 客户端 发送 fin 给服务端 \r\n第二次回收 服务端 发送 ack 给客户端\r\n中间服务端 可能还有数据传输\r\n第三次挥手 服务端 发送 fin 给客户端\r\n第四次挥手 客户端 发送 ack 给 客户端\r\n上述四个挥手 分别 类比 两人再打电话\r\nA对B说 我说完了\r\nB对A说 我知道了\r\n中间 b还有话说\r\nB再对A说 我也说完了\r\nA再对B说 我知道了\r\n双方挂断电话\r\n\r\n如果只有两次 即A对B说我说完了 而没有ack, A不确定B是否知道\"A我说完了\"这句话B听到没有\r\n同理,第三次挥手 B对A说我说完了, 还没等A回答我知道了就挂断,有可能A不知道B已经说完.\r\n\r\ntcp协议之所以可靠 就是由于 三次握手四次挥手 建立的连接, 以及ack回执机制,\r\n如果传输过程中连接断开 又会重新三次握手建立连接, 如果一直没收到ack, 发送方会一直发送相同的消息,等待另一方发ack回执回来",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "manondidi",
            "url": "https://github.com/manondidi"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NTg1ODM4MQ==",
          "body": "> 第一次挥手 客户端 发送 fin 给服务端\r\n> 第二次回收 服务端 发送 ack 给客户端\r\n> 中间服务端 可能还有数据传输\r\n> 第三次挥手 服务端 发送 fin 给客户端\r\n> 第四次挥手 客户端 发送 ack 给 客户端\r\n> 上述四个挥手 分别 类比 两人再打电话\r\n> A对B说 我说完了\r\n> B对A说 我知道了\r\n> 中间 b还有话说\r\n> B再对A说 我也说完了\r\n> A再对B说 我知道了\r\n> 双方挂断电话\r\n> \r\n> 如果只有两次 即A对B说我说完了 而没有ack, A不确定B是否知道\"A我说完了\"这句话B听到没有\r\n> 同理,第三次挥手 B对A说我说完了, 还没等A回答我知道了就挂断,有可能A不知道B已经说完.\r\n> \r\n> tcp协议之所以可靠 就是由于 三次握手四次挥手 建立的连接, 以及ack回执机制,\r\n> 如果传输过程中连接断开 又会重新三次握手建立连接, 如果一直没收到ack, 发送方会一直发送相同的消息,等待另一方发ack回执回来\r\n\r\n\r\n1.A对B说 我说完了\r\n2.B对A说 我知道了\r\n  中间 b还有话说\r\n3.B再对A说 我也说完了\r\n4.A再对B说 我知道了\r\n双方挂断电话\r\n\r\n题主 把 两次挥手改成三次挥手了,我还是拿挂电话的例子\r\n如果步骤4没了 就挂断,那么 B不确定A是否收到 B已经说完了, 而直接挂断\r\n,如果A没收到 A将会一直等待\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "manondidi",
            "url": "https://github.com/manondidi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTEyOTEwMjA=",
    "number": 184,
    "title": "【Q183】tcp 中 time_wait 堆积过多会有什么问题，为什么它超时时间这么长",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE3NzQ4OTE=",
    "number": 185,
    "title": "【Q184】有没有使用过 css variable，它解决了哪些问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTY3ODE3MQ==",
          "body": "css变量减少样式重复定义，比如同一个颜色值要在多个地方重复使用，以前通过less和sass预处理做到，现在css变量也可以做到，方便维护，提高可读性\r\n```\r\n:root{\r\n  --bgcolor: blue;\r\n  --color: red;\r\n}\r\np {\r\n  color: var(--color);\r\n}\r\ndiv {\r\n  backgroung-color: var(--bgcolor);\r\n  color: var(--color)\r\n}\r\n```\r\n在媒体查询中使用，精简代码，减少冗余\r\n```\r\n.box {\r\n  --base-size: 10;\r\n  width: calc(var(--base-size)* 10px);\r\n  height: clac(var(--base-size)* 5px);\r\n  padding:calc(var(--base-size) * 1px);\r\n}\r\n@media screen and (min-width: 1480px) {\r\n  .box{\r\n    --base-size: 8;\r\n  }\r\n}\r\n```\r\n方便在js中使用\r\n```\r\n// 设置变量\r\ndocument.getElementById(\"box\").style.setPropertyValue('--color', 'pink')\r\n// 读取变量\r\ndoucment.getElementById('box').style.getPropertyValue('--color').trim()    //pink\r\n// 删除变量\r\ndocument.getElementById('box').style.removeProperty('--color')\r\n```",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "Cicelychen",
            "url": "https://github.com/Cicelychen"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTcwNDM4OA==",
          "body": "@Cicelychen 赞！而且它与 less/sass 相比，更加灵活，因为它很容易通过 JS 来控制。根据它来做主题切换简直得心应手。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE3ODAwOTM=",
    "number": 186,
    "title": "【Q185】谈谈你对 styled-component 的看法",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTE5MTYyNTY=",
    "number": 187,
    "title": "【Q186】写一个关于全排列，全组合的函数",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU3NjAwMTMxOA==",
          "body": "## `Arragement`\r\n\r\n## `Combination`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTIyOTkyODU=",
    "number": 188,
    "title": "【Q187】当编辑 graphql 的 query 时，如何在编辑器中自动补全",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkyOTk0Mjk2",
          "name": "graphql"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTUwNTI0NjY=",
    "number": 189,
    "title": "【Q188】大数乘法和大数加法",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU0Mjk3NTE=",
    "number": 190,
    "title": "【Q189】performance API 中什么指标可以衡量首屏时间",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1MjcyMDY=",
    "number": 191,
    "title": "【Q190】使用 CSS 如何画一个三角形",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTQ0NDc2OA==",
          "body": "`\r\n.triangle {\r\n    width: 0px;\r\n    height: 0px;\r\n    border: 100px solid;\r\n    border-color: transparent transparent rgba(134, 241, 143,1) transparent;\r\n}\r\n`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Sumarina",
            "url": "https://github.com/Sumarina"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyNDY3NzQxOA==",
          "body": "`.container{\r\nwidth: 0; height:0;\r\nborder-color: transparent;\r\nborder-left: 100px solid #f00;\r\n}`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "senking2",
            "url": "https://github.com/senking2"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTU1NDIxNjg=",
    "number": 192,
    "title": "【Q191】什么是 Open Graph 协议，用来做什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NTI0NjQwNQ==",
          "body": "Open Graph 协议可以让任何一个网页集成到社交图谱中。例如，facebook就是一种社交图谱(social graph)。\r\n一旦一个网页按照该协议进行集成，这个网页就像是社交图谱的一个节点，例如，你的网页集成了open graph协议，\r\n按照协议加入了网页的标题，描述以及图片信息等等，那么你在facebook中分享这个网页的时候，facebook就会按照\r\n你定义的内容来展示这个网页。\r\n\r\n这个协议其实很简单，主要是通过在html中加入一些元数据（meta）标签来实现，例如\r\n在head中加入meta标签，property是以og(open graph)开头, 后面跟着具体属性，content里面是属性的值，\r\n下面这段描述的就是一个类型为 video.movie，标题为 The rock，以及url和图片信息。这个例子就可以当做是\r\n为 https://www.imdb.com/title/tt0117500/ 实现了Open Graph协议、\r\n\r\n```\r\n<html prefix=\"og: http://ogp.me/ns#\">\r\n<head>\r\n<title>The Rock (1996)</title>\r\n<meta property=\"og:title\" content=\"The Rock\" />\r\n<meta property=\"og:type\" content=\"video.movie\" />\r\n<meta property=\"og:url\" content=\"http://www.imdb.com/title/tt0117500/\" />\r\n<meta property=\"og:image\" content=\"http://ia.media-imdb.com/images/rock.jpg\" />\r\n...\r\n</head>\r\n...\r\n</html>\r\n```\r\n结论：\r\n这个协议主要是Facebook提出来的，为了更好的展示用户分享的网页的内容，实现这个协议，有助于SEO优化，告诉google该网页有哪些内容，以及关键词等。\r\n\r\n可以快速实现Open Graph协议的工具有：\r\nWordpress的SEO plugin\r\n使用Facebook的Facebook Page功能\r\n\r\n \r\nReference:\r\n1. The Open Graph Protocol https://ogp.me/\r\n2. Open Graph Protocol for Facebook Explained with Examples  https://www.optimizesmart.com/how-to-use-open-graph-protocol/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "grace-shi",
            "url": "https://github.com/grace-shi"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NTg1MjgwMzI=",
    "number": 193,
    "title": "【Q192】简述你们前端项目中资源的缓存配置策略",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjAyNzUyNzM=",
    "number": 194,
    "title": "【Q193】如何加速 npm install",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzQyOTg5Mw==",
          "body": "换成taobao源?",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CaicoLeung",
            "url": "https://github.com/CaicoLeung"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjAzMjk5NTM=",
    "number": 195,
    "title": "【Q194】npm i 与 npm ci 的区别是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjA0NjEwNzY=",
    "number": 196,
    "title": "【Q195】package-lock.json 有什么作用，如果项目中没有它会怎么样，举例说明",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjI1OTIxMjI=",
    "number": 197,
    "title": "【Q196】前端中遇到过处理二进制的场景吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzg2NDA4MA==",
          "body": "[JavaScript二进制数据处理](http://coinfaces.me/posts/handling-binary-data-using-javascript/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DoubleRayWang",
            "url": "https://github.com/DoubleRayWang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjI2NDMyNTU=",
    "number": 198,
    "title": "【Q197】什么是 TypedArray",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjMxNzkxMDU=",
    "number": 199,
    "title": "【Q198】如何实现类似 lodash.get 函数",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjQ0Mzk3Mzk=",
    "number": 200,
    "title": "【Q199】如何判断文件中的换行符是 LF 还是 CRLF",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg0MDM2MzU=",
    "number": 201,
    "title": "【Q200】前端如何进行多分支部署",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg2NTM0NTY=",
    "number": 202,
    "title": "【Q201】js 中什么是可选链",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU4OTQzODU3Mw==",
          "body": "`?.` 操作符，可以嵌套获取对象的属性值。通过获取对象属性获得的值可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。\r\n\r\n``` javascript\r\nconst o = {}\r\n\r\n// 添加可选链之前\r\no && o.a && o.a.b && o.a.b.c && o.a.b.c.d\r\n\r\n// 添加可选链之后\r\no?.a?.b?.c?.d\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njg5NTUzMjc=",
    "number": 203,
    "title": "【Q202】如何实现一个深拷贝",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NjkzMjAxNTM=",
    "number": 204,
    "title": "【Q203】对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTQyOTMwMw==",
          "body": "如果开启了tree shaking应该不会打包。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "blank121",
            "url": "https://github.com/blank121"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NzMzOTAwMQ==",
          "body": "tree shaking通过扫描所有 ES6 的 export，找出被 import 的内容并添加到最终代码中。tree shaking的使用时 **源码必须遵循 ES6 的模块规范 (import & export)，如果是 CommonJS 规范 (require) 则无法使用。** 也就是说，需要给babel里面配置一下\"es6不要解析\"：\r\n```\r\n// .babelrc\r\n\r\n{\r\n    \"presets\": [\r\n        [\"es2015\", {\"modules\": false}]\r\n    ]\r\n}\r\n```\r\ntree shaking在webpack2.0里面需要进行手动设置，webpack3和webpack4里面为默认设置。\r\n### 一、对于方法的处理\r\n**通过tree shaking设置后，webpack里面会将没有使用的方法标记为：\r\n`unused harmony export xxx`，但代码仍然保留。（webpack编译后的源码里面仍然包含没有使用的方法）**\r\n随后使用`UglifyJSPlugin`进行第二步，将已经标记的没有使用的方法进行删除。\r\n### 二、对于类的处理\r\n**与标记方法不同，webpack打包时会将整个类进行标记，也就是说，即使类里面的方法没有被使用也会进行打包编译。** 这表明 webpack tree shaking 只处理顶层内容，例如类和对象内部都不会再被分别处理。\r\n综上所述，可以得出 **“对于已经 import 但未实际使用的模块使用 webpack 还会对它打包”** 。\r\n当然，想要精简代码是可以实现的，具体文章参考：[Webpack 之 treeShaking](https://www.jianshu.com/p/cf930283d404)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "ming131419",
            "url": "https://github.com/ming131419"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk4NzQ5Nzg=",
    "number": 205,
    "title": "【Q204】Node 中如何判断一个路径是文件还是文件夹",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTI5MTU0Ng==",
          "body": "const  statInfo = fs.lstatSync(\"./xx\").\r\nstatInfo.isDirectory()",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "PlutoCA",
            "url": "https://github.com/PlutoCA"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Njk5ODMyNTU=",
    "number": 206,
    "title": "【Q205】Code Splitting 的原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5MTMzODg1MA==",
          "body": "https://www.toutiao.com/i6790221102615364108/",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "yt253284494",
            "url": "https://github.com/yt253284494"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA2NzQ0ODEz",
          "name": "webpack"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzE0NjE5MTU=",
    "number": 207,
    "title": "【Q206】no-cache 与 no-store 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5OTE5MjU5MA==",
          "body": "no-cache 可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用 \r\nno-store 是禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "lijiayi01",
            "url": "https://github.com/lijiayi01"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzMyNDkxODA=",
    "number": 208,
    "title": "【Q207】什么是隔离级",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzM1Njk3MTI=",
    "number": 209,
    "title": "【Q208】在 postgres 中如何查看慢查询语句",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzM5ODUxMzc=",
    "number": 210,
    "title": "【Q209】如何得知一条 SQL 执行的时长？",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzQ2NTEyMDc=",
    "number": 211,
    "title": "【Q210】如何判断当前环境时移动端还是PC端",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5Mzk1MjgzNg==",
          "body": "判断 `navigator.userAgent`，对于 Android/iPhone 可以匹配以下正则\r\n\r\n``` js\r\nconst appleIphone = /iPhone/i;\r\nconst appleIpod = /iPod/i;\r\nconst appleTablet = /iPad/i;\r\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\r\nconst androidTablet = /Android/i;\r\n```\r\n\r\n当然，不要重复造轮子，推荐一个库: <https://github.com/kaimallea/isMobile>\r\n\r\n``` js\r\nimport isMobile from 'ismobilejs'\r\n\r\nconst mobile = isMobile()\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzc3NTUzMA==",
          "body": "```\r\nisPc() {\r\n    var userAgentInfo = navigator.userAgent\r\n    var Agents = new Array(\r\n      'Android',\r\n      'iPhone',\r\n      'SymbianOS',\r\n      'Windows Phone',\r\n      'iPad',\r\n      'iPod'\r\n    )\r\n    var flag = true\r\n    for (var v = 0; v < Agents.length; v++) {\r\n      if (userAgentInfo.indexOf(Agents[v]) > 0) {\r\n        flag = false\r\n        break\r\n      }\r\n    }\r\n    return flag\r\n  }\r\n```\r\n嘿嘿照搬了一段商用的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzc3NzEyNw==",
          "body": "@SageSanyue 直接用 `Array.prototype.some` 就简单多了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzc4NDMzNw==",
          "body": "> @SageSanyue 直接用 `Array.prototype.some` 就简单多了\r\n\r\n确实噢😯我完全没动我的zhu脑子:(\r\n```\r\nisPc() {\r\n    var userAgentInfo = navigator.userAgent\r\n    var Agents = new Array(\r\n      'Android',\r\n      'iPhone',\r\n      'SymbianOS',\r\n      'Windows Phone',\r\n      'iPad',\r\n      'iPod'\r\n    )\r\n    var flag = true\r\n    flag = !Agents.some((ele) => {\r\n        return userAgentInfo.indexOf(ele) > 0 \r\n    })\r\n    return flag\r\n  }\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "SageSanyue",
            "url": "https://github.com/SageSanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzQ3MzIxNzM=",
    "number": 212,
    "title": "【Q211】React hooks 中 useCallback 的使用场景是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUxNTEzNTk=",
    "number": 213,
    "title": "【Q212】在 postgres/mysql 中如何判断当前版本是多少",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDMzODQ4Mw==",
          "body": "使用 `select version()`\r\n\r\npostgres 示例如下:\r\n\r\n``` sql\r\npostgres@db:school> select version()\r\n+---------------------------------------------------------------------------------------+\r\n| version                                                                               |\r\n|---------------------------------------------------------------------------------------|\r\n| PostgreSQL 12.1 on x86_64-pc-linux-musl, compiled by gcc (Alpine 8.3.0) 8.3.0, 64-bit |\r\n+---------------------------------------------------------------------------------------+\r\nSELECT 1\r\nTime: 0.028s\r\n```\r\n\r\nmysql 示例如下：\r\n\r\n``` sql\r\n> select version()\r\n+-------------+\r\n| version()   |\r\n|-------------|\r\n| 5.6.16-log  |\r\n+-------------+\r\n1 row in set\r\nTime: 0.003s\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzUzNjc3NTg=",
    "number": 214,
    "title": "【Q213】什么是隔离级，都有哪些隔离级",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDU0ODU5Mg==",
          "body": "隔离级事关并发事务的隔离机制，ANSI SQL 中定义了四种隔离级，分别是\r\n\r\n+ Read Uncommited\r\n+ Read Committed\r\n+ Repetable Read\r\n+ Serializable",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU1MzU2NjM=",
    "number": 215,
    "title": "【Q214】input 中监听值的变化是在监听什么事件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDY0NTQxNg==",
          "body": "可以**实时**监听值的变化的事件有以下几种\r\n\r\n+ keypress\r\n+ keydown\r\n+ keyup\r\n+ input\r\n\r\n注: `onChange` 无法做到实时监听，因为 onChange 需要失去焦点才能触发",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTAwMDQ5Mw==",
          "body": "oninput不用考虑是否失去焦点，不管js操作还是键盘鼠标手动操作，只要HTML元素属性发生改变即可立即捕获到",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "sunhua-2217",
            "url": "https://github.com/sunhua-2217"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTAxMTU5Mw==",
          "body": "**onchange:**\r\n\r\n**Supported HTML tags:** \r\n\r\n```\r\n<input type=\"checkbox\">, <input type=\"file\">, <input type=\"password\">, <input type=\"radio\">, <input type=\"range\">, <input type=\"search\">, <input type=\"text\">, <select> and <textarea>\r\n```\r\n\r\n\r\nThe onchange attribute fires the moment when the value of the element is changed.\r\n\r\nTip: This event is similar to the oninput event. The difference is that the oninput event occurs immediately after the value of an element has changed, **while onchange occurs when the element loses focus**. The other difference is that the onchange event also works on <select> elements.",
          "star": {
            "totalCount": 2
          },
          "author": {
            "login": "qixMan",
            "url": "https://github.com/qixMan"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTU3MDQ0OA==",
          "body": "@CaiyueDamowang 测试了好像不行\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "one-pupil",
            "url": "https://github.com/one-pupil"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjA1NTM0Mg==",
          "body": "> @CaiyueDamowang 测试了好像不行\r\n\r\n嗯，不行。。\r\n在html标签中onchange可以在失去焦点触发",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "CaiyueDamowang",
            "url": "https://github.com/CaiyueDamowang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjIyOTI=",
    "number": 216,
    "title": "【Q215】什么是跨域，如何解决跨域问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NDk3MjkzOA==",
          "body": "### 跨域\r\n\r\n协议，域名，端口，三者有一不一样，就是跨域\r\n\r\n### 如何解决跨域\r\n\r\n目前有两种最常见的解决方案：\r\n\r\n1. CORS，在服务器端设置几个响应头\r\n1. Reverse Proxy，在 nginx/traefik/haproxy 等反向代理服务器中设置为同一域名\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQxNDM=",
    "number": 217,
    "title": "【Q216】你对未来的工作有什么期待",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjQ3NTA=",
    "number": 218,
    "title": "【Q217】你对未来的三年规划和五年规划是什么样的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MjUwMTM=",
    "number": 219,
    "title": "【Q218】当你入职后发现压力过大怎么办",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzE2OTI=",
    "number": 220,
    "title": "【Q219】工作中你有没有很佩服的人",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzQ0NjQ=",
    "number": 221,
    "title": "【Q220】请简述一下 event loop",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5MzgwOTU=",
    "number": 222,
    "title": "【Q221】作为技术负责人，你每天的工作是什么样的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzU5Mzg0NTU=",
    "number": 223,
    "title": "【Q222】数据库中如何查看当前的连接数",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzA2MTA=",
    "number": 224,
    "title": "【Q223】数据库查询如何更好地利用数据库缓存进行优化",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYyMzQ1MDM=",
    "number": 225,
    "title": "【Q224】误操作了一个 delete from 语句，如何恢复数据",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzNjY1MzE=",
    "number": 226,
    "title": "【Q225】你相比去年，有哪些成长",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzNzQyNDI=",
    "number": 227,
    "title": "【Q226】数据库死锁是怎么产生的",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NTMyMDc1Mw==",
          "body": "多个事务对资源的交替顺序访问，如\r\n\r\n事务1，访问A表，A表锁住，访问B表，此时B表却被事务2锁住，等待\r\n事务2，访问B表，B表锁住，访问A表，此时A表却被事务1锁住，等待\r\n\r\n由此观之，此死锁出现的条件极为苛刻\r\n\r\n1. 并发，产生多个事务\r\n1. 顺序，对相同资源的不同顺序访问 (干嘛要不同顺序呀)\r\n1. 时机，恰好两个事物都刚刚走完了第一步\r\n\r\n[更多示例](https://www.cnblogs.com/wezheng/p/8366029.html)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzYzODE4ODY=",
    "number": 228,
    "title": "【Q227】你如何看待996",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY3MzE4MjE=",
    "number": 229,
    "title": "【Q228】如何实现一个 flatMap 函数 (头条)",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzg5MTUwMg==",
          "body": "没说不让用flat；所以有个取巧的办法\r\nconst flatMap = arr => arr.flat().map(_ => _);",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DoubleRayWang",
            "url": "https://github.com/DoubleRayWang"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzY4Mzc5Njg=",
    "number": 230,
    "title": "【Q229】在数据库中一个字段如果是字符串类型的，那应该设置哪种数据类型",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjIwNDExNg==",
          "body": "以下答案仅说明在 postgres 中的情况：\r\n\r\n在 postgres 有三种 `varchar`，`char` 以及 `text`，其中三者没有性能差异，见官方文档\r\n\r\n> Different from other database systems, in PostgreSQL, there is no performance difference among three character types. In most situation, you should use text or varchar, and varchar(n) if you want PostgreSQL to check for the length limit\r\n\r\n所以，选择 `text` 是最好的方案",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzcyNDEyNjQ=",
    "number": 231,
    "title": "【Q230】如何裁剪图片 (情景：选择头像)",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzcyNTQwMTQ=",
    "number": 232,
    "title": "【Q231】你周末都喜欢做些什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5Njk1NDQxNA==",
          "body": "打篮球，看电影，看不下书怎么办",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "HoweZhang",
            "url": "https://github.com/HoweZhang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzAzMDM5Ng==",
          "body": "> 打篮球，看电影，看不下书怎么办\r\n\r\n丰富而有意义的生活啊，有这样的美好生活，还看书干嘛？工作日再看呀",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTI5ODk1Mw==",
          "body": "switch不香么",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "allenGKC",
            "url": "https://github.com/allenGKC"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMDExOTI=",
    "number": 233,
    "title": "【Q232】当有大量的文本库时，如何做一个字云",
    "body": "如果对去重的每个字都做计数的话，会不会性能过差",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMTIyNzY=",
    "number": 234,
    "title": "【Q233】一个关于并发更新的事务以及隔离级的问题",
    "body": "当多并发场景下有以下事务执行 (计数器自增)，会出现什么问题\r\n\r\n``` sql\r\nbegin;\r\n\r\n-- select count from counter;\r\n\r\nupdate counter set count = count + 1 where id = 1;\r\n\r\ncommit;\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjA3MDY3OA==",
          "body": "如果在 pg 下:\r\n\r\n如果隔离级为 RC，则多个事务在更新同一行时，会受到阻塞 (Row Lock)\r\n如果隔离级为 RR，则多个事务在更新同一行时，会报错\r\n\r\n```\r\ncould not serialize access due to concurrent update\r\n```\r\n\r\nmysql 未测试",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzczMzAzMTE=",
    "number": 235,
    "title": "【Q234】以下 SQL 语句会有什么问题 (悲观锁)",
    "body": "一个计数器，自增一\r\n\r\n``` sql\r\nbegin;\r\nselect count from user;\r\n\r\n-- 根据以上 SQL 查询出来的 count 来进行自增\r\n-- 如果在此次事务中，已有多次事务对 count 进行了多次更改怎么办？\r\nupdate user set count = $count + 1 where id = 1;\r\ncommit;\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NjA4NjI3MA==",
          "body": "在并发情况下会出现问题，先查看本次事务的流程\r\n\r\n1. 查询当前计数 -> 此时为 10\r\n1. 对当前计数自增 -> 此时为 11？**在自增时，有可能被多并发的其它事务已经自增到 100 了，此时若设置为 11，肯定有问题**\r\n\r\n**如何解决？**\r\n\r\n要在第一步时加锁，同一时间只放行一个事务，可以设置分布式锁和悲观锁\r\n\r\n+ **分布式锁** (redis)：`SET LOCK_KEY RANDOM_VALUE EX 100 NX`\r\n+ **悲观锁**：`select count from user for update`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg1NjUwNTU=",
    "number": 236,
    "title": "【Q235】useEffect 中如何使用 async/await",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzA3ODA5NQ==",
          "body": "`useEffect` 的回调参数无法返回 `Promise`，因此无法使用 `async/await`，此时可以选择再包装一层函数\r\n\r\n``` jsx\r\nasync function fetchMyAPI() {\r\n  let response = await fetch('api/data')\r\n  response = await res.json()\r\n  dataSet(response)\r\n}\r\n\r\nuseEffect(() => {\r\n  fetchMyAPI();\r\n}, []);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzg3MDc0MTI=",
    "number": 237,
    "title": "【Q236】主域名的 SEO 是否比二级域名要更好",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1NzkxOTExOTg=",
    "number": 238,
    "title": "【Q237】以下代码，koa 会返回什么数据",
    "body": "根据有无 `await next()` 判断以下代码输出结果\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  ctx.body = 'hello, 1'\r\n  await next()\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```\r\n\r\n``` js\r\nconst Koa = require('koa')\r\nconst app = new Koa()\r\n\r\napp.use(async (ctx, next) => {\r\n  await next()\r\n  ctx.body = 'hello, 1'\r\n})\r\n\r\napp.use(ctx => {\r\n  ctx.body = 'hello, 2'\r\n})\r\n\r\napp.listen(3000)\r\n```",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzU4MDQyOA==",
          "body": "根据 koa 的洋葱模型，返回结果是\r\n\r\n```\r\nhello, 1\r\n\r\nhello, 2\r\n\r\nhello, 1\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1Nzk5NDY4NTQ=",
    "number": 239,
    "title": "【Q238】什么是服务雪崩，如何避免",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5NjAxMzY=",
    "number": 240,
    "title": "【Q239】Node 如何进行进程间通信 ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5ODk5MTU4MQ==",
          "body": "对于 spawn/fork 出来的父子进程来说，可以通过 pipe 的方式\r\n\r\n+ `process.on('message')`/`process.send`\r\n+ `stdin.on/stdout.write`\r\n\r\n对于并无相关的进程\r\n\r\n+ `socket`\r\n+ `message queue`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5NzUxNjc=",
    "number": 241,
    "title": "【Q240】如何实现一个 async/await ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODU3Mzc2Mg==",
          "body": "```js\r\n/**\r\n * async的执行原理\r\n * 其实就是自动执行generator函数\r\n * 暂时不考虑genertor的编译步骤（更复杂）\r\n */\r\n\r\nconst getData = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(\"data\"), 1000))\r\n\r\n// 这样的一个async函数 应该再1秒后打印data\r\nasync function test() {\r\n  const data = await getData()\r\n  console.log('data: ', data);\r\n  const data2 = await getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\n// async函数会被编译成generator函数 (babel会编译成更本质的形态，这里我们直接用generator)\r\nfunction* testG() {\r\n  // await被编译成了yield\r\n  const data = yield getData()\r\n  console.log('data: ', data);\r\n  const data2 = yield getData()\r\n  console.log('data2: ', data2);\r\n  return 'success'\r\n}\r\n\r\nfunction asyncToGenerator(generatorFunc) {\r\n  return function() {\r\n    const gen = generatorFunc.apply(this, arguments)\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function step(key, arg) {\r\n        let generatorResult\r\n        try {\r\n          generatorResult = gen[key](arg)\r\n        } catch (error) {\r\n          return reject(error)\r\n        }\r\n\r\n        const { value, done } = generatorResult\r\n\r\n        if (done) {\r\n          return resolve(value)\r\n        } else {\r\n          return Promise.resolve(value).then(\r\n            function onResolve(val) {\r\n              step(\"next\", val)\r\n            },\r\n            function onReject(err) {\r\n              step(\"throw\", err)\r\n            },\r\n          )\r\n        }\r\n      }\r\n      step(\"next\")\r\n    })\r\n  }\r\n}\r\n\r\nconst testGAsync = asyncToGenerator(testG)\r\ntestGAsync().then(result => {\r\n  console.log(result)\r\n})\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "sl1673495",
            "url": "https://github.com/sl1673495"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNjQyNzAzNg==",
          "body": "公众号里这篇文章留的 github 网址有误，那个 url 打开 404 ：）",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "crossz",
            "url": "https://github.com/crossz"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODA5ODQxNjI=",
    "number": 242,
    "title": "【Q241】如何使用 async/await 实现 Promise.all 的效果",
    "body": "如获取三个用户的信息，使用 `Promise.all` 的写法\r\n\r\n``` js\r\nconst users = await Promise.all(getUser(1), getUser(2), getUser(3))\r\n```\r\n\r\n那如何不使用 `Promise.all` 实现以上效果",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDU5OTA3OTQ4Mw==",
          "body": "使用 `async`/`await` 实现\r\n\r\n``` js\r\nconst user1 = getUser(1)\r\nconst user2 = getUser(2)\r\nconst user3 = getUser(3)\r\n\r\nconst u1 =  await user1\r\nconst u2 =  await user2\r\nconst u3 =  await user3\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzODA0MTQ0Mw==",
          "body": "```\r\nconst all = (list) => {\r\n    const res = new Promise((resolve, reject) => {\r\n        let length = list && list.length\r\n        let count = 0\r\n        let result = []\r\n        if(!list || list.length === 0) {\r\n            resolve(result)\r\n        }\r\n        list.forEach(async (item, index) => {\r\n            try {\r\n                const res = await item\r\n                result[index] = res\r\n                count ++\r\n                if(count === length) {\r\n                    resolve(result)\r\n                }\r\n            } catch(err) {\r\n                reject(err)\r\n            }\r\n        });\r\n    })\r\n    return res\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "Misxiao",
            "url": "https://github.com/Misxiao"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODEyNDc5ODc=",
    "number": 244,
    "title": "【Q242】有没有用过 continuous local storage，用在了哪里",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODEyNTE3NTg=",
    "number": 245,
    "title": "【Q243】有没有遇到 js 捕捉不到异常堆栈信息的情况",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE1OTc0MTM=",
    "number": 246,
    "title": "【Q244】Promise 在异步资源的生命周期 (async_hooks) 中是如何被销毁的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY4MDQ=",
    "number": 247,
    "title": "【Q245】有没有用过 Promise.allSettled() ，它是干什么的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODE3NDY5ODg=",
    "number": 248,
    "title": "【Q246】谈谈你对微服务的理解，试着画一个脑图",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODQzOTE5NTQ=",
    "number": 249,
    "title": "【Q247】在 node 中如何监听异步资源的生命周期",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODg0MTkwNDY=",
    "number": 250,
    "title": "【Q248】测试中 TDD 与 BDD 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk3MDc2NjE=",
    "number": 251,
    "title": "【Q249】使用 js 实现一个 lru cache",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk3MzI3NDk=",
    "number": 252,
    "title": "【Q250】刚刚启动了一个服务，如何知道这个服务对应的端口号是多少",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU2MTA0NTgx",
          "name": "devops"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1ODk5NDAwODU=",
    "number": 253,
    "title": "【Q251】node --max-old-space-size=4096 是什么意思",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNTk3MzU=",
    "number": 254,
    "title": "【Q252】https 中如何保证证书是可信任的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzAzODE=",
    "number": 255,
    "title": "【Q253】cookie 有哪些字段",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTkwOA==",
          "body": "+ path\r\n+ domain\r\n+ key\r\n+ value\r\n+ httpOnly\r\n+ simeSite",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMjE5NDA2NQ==",
          "body": "name   cookie 名称\r\nvalue    cookie 值\r\ndomain 可以访问cookie的域名\r\npath 可以访问此cookie 的页面路径 \r\nexpires/Max-Age 超时时间\r\nsize  这个cookie 的大小\r\nhttp 字段  cookie的httponly属性\r\nsecure 设置是否只能通过https来传递此条cookie",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "chenheng-cmd",
            "url": "https://github.com/chenheng-cmd"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTAyNzQzOTc=",
    "number": 256,
    "title": "【Q254】进程与线程的区别是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTE3NDIzMzU=",
    "number": 257,
    "title": "【Q255】图片防盗链原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzEyMzkzNw==",
          "body": "请求头中的 refer 来判断是否屏蔽图片",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI0MjYzNzE=",
    "number": 258,
    "title": "【Q256】如何理解 Node 的异步非阻塞IO",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ1Mjk=",
    "number": 259,
    "title": "【Q257】爬虫中如何实现一个调度器",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTQ5ODE=",
    "number": 260,
    "title": "【Q258】如何实现一个分布式的爬虫",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Nzk5NQ==",
          "body": "可以通过 redis 实现一个分布式的 url 调度器 (Set)，多个分布式爬虫的爬取器从调度器中统一取地址进行爬取",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTI3MTU0Nzg=",
    "number": 261,
    "title": "【Q259】爬虫如何实现一个去重器",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTMzMjQ0NjA=",
    "number": 262,
    "title": "【Q260】如何实现单点登录",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODk2Njg0NA==",
          "body": "一张来 [单点登录原理与简单实现](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png) 的图\r\n\r\n![](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTMzNzMyODk=",
    "number": 263,
    "title": "【Q261】当写爬虫时，因爬取过多被禁掉 IP 怎么解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwODk2MTMxMA==",
          "body": "可以维护一个 IP 地址池，通过 Proxy 的方式去爬取网页",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxOTU2NjA5OTU2",
          "name": "爬虫"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3MzY5NzA=",
    "number": 264,
    "title": "【Q262】当一个排期五天的任务需要在两天后上线如何解决",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3NTQyOTY=",
    "number": 265,
    "title": "【Q263】你们项目的测试覆盖率是怎么做的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTM3NzI3Mjk=",
    "number": 266,
    "title": "【Q264】当 Node 应用发生 gc 时，如何监控",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTQyOTM1NTE=",
    "number": 267,
    "title": "【Q265】Node 应用中如何查看 gc 的日志",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTM3NjExNg==",
          "body": "通过开启参数 `--trace-gc` 与 `--trace-gc-verbose`\r\n\r\n``` bash\r\n$ node --trace-gc index.js\r\n\r\n[10711:0x3507b20]    36425 ms: Mark-sweep 28.6 (48.2) -> 19.3 (46.7) MB, 3.9 / 0.0 ms  (+ 10.4 ms in 8 steps since start of marking, biggest step 6.9 ms, walltime since start of marking 77 ms) (average mu = 0.997, current mu = 0.997) finalize incremental marking via task GC in old space requested\r\n[10711:0x3507b20]    36434 ms: Scavenge 21.0 (46.7) -> 5.7 (46.7) MB, 1.0 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36494 ms: Scavenge 21.1 (46.7) -> 6.2 (46.7) MB, 2.3 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n[10711:0x3507b20]    36562 ms: Scavenge 21.1 (46.7) -> 6.0 (46.7) MB, 2.8 / 0.0 ms  (average mu = 0.997, current mu = 0.997) allocation failure\r\n```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTQ0NTExNDU=",
    "number": 268,
    "title": "【Q266】bind 与 call/apply 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYwOTQxNTUzNg==",
          "body": "他们都是绑定 this 的，但是\r\n\r\n1. `bind` 返回函数\r\n1. `call/apply` 直接执行函数",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTUxNDcwNDg=",
    "number": 269,
    "title": "【Q267】CSP 是干什么用的了",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzkxNjc5MQ==",
          "body": "http://www.ruanyifeng.com/blog/2016/09/csp.html",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DoubleRayWang",
            "url": "https://github.com/DoubleRayWang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyNDQxOTc5Ng==",
          "body": "`CSP` 可以最大限度地防止 `XSS` 攻击，它只允许加载指定的脚本及样式等，通过 http 的响应头 `Content Security Policy` 控制。\r\n\r\n如果网站必须加载内联脚本 (inline script) ，则可以提供一个 `nonce` 才能执行脚本，这样攻击者无法注入脚本进行攻击。\r\n\r\n可参考阮一峰 [Content Security Policy 入门教程](http://www.ruanyifeng.com/blog/2016/09/csp.html)",
          "star": {
            "totalCount": 1
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMTUxODY3Nw==",
          "body": "### Content Security Policy (CSP)\r\n\r\n**介绍：**\r\n1. 解决 XSS 最优办法\r\n2. 可以设置信任域名才可以访问 script / audio / video / image ...\r\n\r\n\r\n**防止 XSS 例子：**\r\n攻击者通过 恶意脚本(假设有执行外部脚本) 注入到系统内，显示给访问用户，以此来获取用户信息\r\n我们可以通过 CSP 来设置信任域名才可以执行 .js 脚本。\r\n\r\n\r\n**如何设置：**\r\n1. HTTP 请求头\r\n2. Meta 标签\r\n\r\nMDN：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\r\n\r\n兼容性：IE >= 10",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "zzetao",
            "url": "https://github.com/zzetao"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTU4NjcwMjA=",
    "number": 270,
    "title": "【Q268】你如何看待 serverless",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTcyNjcyMzE=",
    "number": 271,
    "title": "【Q269】什么是 XSS 攻击，如何避免",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTczMzI4OTc=",
    "number": 272,
    "title": "【Q270】一张员工表，一个字段代表它的上级，如何查询该员工的所有上级",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTc4ODU4NjY=",
    "number": 273,
    "title": "【Q271】react hooks 的原理是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU1OTkzMjk2NjE=",
    "number": 274,
    "title": "【Q272】如何查看你们 JS 项目中应采用的 node 版本",
    "body": "当入职新公司，接手一个新的项目时，如何知道这个项目需要的 node 版本是多少",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzkxMjU5NQ==",
          "body": "如果项目使用的yarn和typescript，可以查看yarn.lock里的@types/node@* 的version",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "DoubleRayWang",
            "url": "https://github.com/DoubleRayWang"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzk0OTc0MA==",
          "body": "1. `packageJson.engines`，第三方模块都会有，自己的项目中有可能有\r\n1. `pm2.app[].interpreter`，如果采用 `pm2` 部署，可以查看 interpreter 选项，但不保证该项存在\r\n1. `FROM`，如果采用 `docker` 部署，查看基础镜像 `Dockerfile` 中 node 的版本号\r\n1. 如果以上方式都不可以，那只有问人了",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        },
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzk5OTMyMQ==",
          "body": "@DoubleRayWang 我试了一下，这种方法应该是不靠谱的",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDAyODAyMjA=",
    "number": 275,
    "title": "【Q273】http2 中的首部压缩的实现原理是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxNDAzMTYyOA==",
          "body": "`HPACK` 协议，其中原理是哈夫曼编码及索引表 (看来常用的数据结构及算法要有所了解)，以下内容摘自 [谷歌开发者文档：http2](https://developers.google.com/web/fundamentals/performance/http2/)\r\n\r\n> 每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。 （请参阅测量和控制协议开销。） 为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：\r\n>\r\n> 1. 这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。\r\n> 1. 这种格式要求客户端和服务器同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），此列表随后会用作参考，对之前传输的值进行有效编码。\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDEyMDEwNDQ=",
    "number": 276,
    "title": "【Q274】如何获取你们 Node 项目的 cpu profile 快照",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDEyMzM5NDg=",
    "number": 277,
    "title": "【Q275】解释下 OLTP 与 OLAP",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2NjM4NTQ=",
    "number": 278,
    "title": "【Q276】如何查看 node_modules(某一文件夹) 的体积有多大",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjA4MjUxNQ==",
          "body": "`du` 命令可以查看磁盘的使用情况，从它可以看出来文件及目录的大小\r\n\r\n``` bash\r\n# -d 搜索深度\r\n$ du -hd 0 node_modules\r\n132M    node_modules\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ3MDQ=",
    "number": 279,
    "title": "【Q277】redux 解决什么问题，还有什么其他方案",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDI2OTQ4NTg=",
    "number": 280,
    "title": "【Q278】为什么不能在表达式里面定义 react hooks",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU4MzQ3NDIy",
          "name": "react"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDU2MzU3MTc=",
    "number": 281,
    "title": "【Q279】display: inline 的元素设置 margin 和 padding 会生效吗",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYxODQ3MjE4MQ==",
          "body": "可参考文章 http://maxdesign.com.au/articles/inline/\r\n\r\ninline 元素的 margin 与 padding 左右生效，上下不生效",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYxNDk5ODQ=",
    "number": 282,
    "title": "【Q280】html 的默认 display 属性是多少",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNjg3NTA=",
    "number": 283,
    "title": "【Q281】响应式布局需要注意哪一些",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDYyNzU0MDU=",
    "number": 284,
    "title": "【Q282】对一个非定长宽的块状元素如何做垂直水平居中",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDg4NjE3NzM=",
    "number": 285,
    "title": "【Q283】http 请求头中的 X-Forwarded-For 代表什么意思",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMTA2MzMzOQ==",
          "body": "`X-Forwarded-For` 被反向代理器生成，如 nginx，traefik 等，一般用作标识客户端真实的 IP 地址，目前已成为事实上的标准。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk0MzQwODA=",
    "number": 286,
    "title": "【Q284】prefetch 与 preload 的区别是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMTUyODQ5OQ==",
          "body": "1. `preload` 加载当前路由必需资源，优先级高\r\n1. `prefetch` 优先级低，在浏览器 idle 状态时加载资源。一般用以加载其它路由资源，如当页面出现 Link，可 prefetch 当前 Link 的路由资源。（next.js 默认会对 link  做懒加载+prefetch，即当某条 Link 出现页面中，即自动 prefetch 该 Link 指向的路由资源\r\n\r\n> prefetch - Prefetch the page in the background. Defaults to true. Any <Link /> that is in the viewport (initially or through scroll) will be preloaded.\r\n\r\n更多信息可参考以下链接：\r\n\r\n+ [用 preload 预加载页面资源](https://juejin.im/post/5a7fb09bf265da4e8e785c38)\r\n+ [Using Preload and Prefetch in Your HTML to Load Assets](https://alligator.io/html/preload-prefetch/)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk3MTU2NjE=",
    "number": 287,
    "title": "【Q285】有没有做过裁剪头像图片的需求，如何实现",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MDk3NDM2NTY=",
    "number": 288,
    "title": "【Q286】在服务端应用中如何获得客户端 IP",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMTcxNTI4NA==",
          "body": "**如果有 `x-forwarded-for` 的请求头，则取其中的第一个 IP，否则取建立连接 socket 的 remoteAddr。**\r\n\r\n而 `x-forwarded-for` 基本已成为了基于 proxy 的标准HTTP头，格式如下，可见第一个 IP 代表其真实的 IP，可以参考 MDN [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)\r\n\r\n``` js\r\nX-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178\r\nX-Forwarded-For: <client>, <proxy1>, <proxy2>\r\n```\r\n\r\n以下是 `koa` 获取 IP 的方法\r\n\r\n``` js\r\n  get ips() {\r\n    const proxy = this.app.proxy;\r\n    const val = this.get(this.app.proxyIpHeader);\r\n    let ips = proxy && val\r\n      ? val.split(/\\s*,\\s*/)\r\n      : [];\r\n    if (this.app.maxIpsCount > 0) {\r\n      ips = ips.slice(-this.app.maxIpsCount);\r\n    }\r\n    return ips;\r\n  },\r\n\r\n  get ip() {\r\n    if (!this[IP]) {\r\n      this[IP] = this.ips[0] || this.socket.remoteAddress || '';\r\n    }\r\n    return this[IP];\r\n  },\r\n```\r\n\r\n参见源码: <https://github.com/koajs/koa/blob/master/lib/request.js#L433>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTE5NDk0NDE=",
    "number": 289,
    "title": "【Q287】在 redis 中如何查看版本号",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyMzUyMTQ0OA==",
          "body": "``` bash\r\n$ redis-server -v\r\nRedis server v=5.0.7 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=fbc6fab733127977\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTI1OTQ4Nzc=",
    "number": 290,
    "title": "【Q288】如何求数组中的 TOP k",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYyNDA1NDE1Nw==",
          "body": "1. 取数组中前 k 个数做小顶堆，堆化\r\n1. 数组中的其它数逐一与堆顶元素比较，若大于堆顶元素，则插入该数\r\n\r\n时间复杂度 O(nlg(k))",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjkwMDg5OTM2",
          "name": "algorithm"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTcxNzQ=",
    "number": 291,
    "title": "【Q289】Node 中循环引用会发生什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTQ4MTc0Nzg=",
    "number": 292,
    "title": "【Q290】Node 中 require 时发生了什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MTU4MjgwMzc=",
    "number": 293,
    "title": "【Q291】node 中的垃圾回收有哪些机制",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMwNjE1NDk=",
    "number": 294,
    "title": "【Q292】peerDependency 是为了解决什么问题",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMjc3NDYyOA==",
          "body": "<https://indepth.dev/npm-peer-dependencies/>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjMzMTk4NDM=",
    "number": 295,
    "title": "【Q293】semver 指什么，试图解释一下",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjM4NDQzODI=",
    "number": 296,
    "title": "【Q294】optionalDependencies 的使用场景是什么",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMzIxOTM3Mg==",
          "body": "当一个包是可依赖可不依赖时，可采用 `optionalDependencies`，但需要在代码中做好异常处理。\r\n\r\n如 [chokidar](https://github.com/paulmillr/chokidar) 对 `fsevents` 的引入\r\n\r\n``` json\r\n{\r\n  \"optionalDependencies\": {\r\n    \"fsevents\": \"~2.1.2\"\r\n  }\r\n}\r\n```\r\n\r\n``` js\r\nlet fsevents;\r\ntry {\r\n  fsevents = require('fsevents');\r\n} catch (error) {\r\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ2OTc5NDY=",
    "number": 297,
    "title": "【Q295】fetch 中 crendentials 指什么意思，可以取什么值",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzMzg4ODYyNQ==",
          "body": "`credentials` 指在使用 `fetch` 发送请求时是否应当发送 `cookie`\r\n\r\n+ `omit`: 从不发送 `cookie`.\r\n+ `same-origin`: 同源时发送 `cookie`  (浏览器默认值)\r\n+ `include`: 同源与跨域时都发送 `cookie`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjQ5NDM2NDc=",
    "number": 298,
    "title": "【Q296】package-lock.json 与 yarn.lock 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzA3OTU2MjIw",
          "name": "前端工程化"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjUzODM5MzY=",
    "number": 299,
    "title": "【Q297】服务器的平均负载如何计算",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNDQzNTExOA==",
          "body": "`load average` 指单位时间内运行态进程及不可中断进程的平均进程数，运行态进程指正在使用或者\r\n 等待使用 CPU 的进程，不可中断进程指正等待一些 IO 操作的进程。可使用 `uptime` 查看此指标。\r\n\r\n ```bash\r\n $ uptime\r\n  16:48:09 up 2 days, 23:43,  2 users,  load average: 0.01, 0.21, 0.20\r\n ```\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU0NzI2ODk=",
    "number": 300,
    "title": "【Q298】如何创建一个进程",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTA1NTY0NQ==",
          "body": "+ `exec`\r\n+ `fork`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzQ1MjU2MzU2",
          "name": "c"
        },
        {
          "id": "MDU6TGFiZWwxNjkxMDQ3MDQ2",
          "name": "os"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjAzNTQ=",
    "number": 301,
    "title": "【Q299】serverless 中如何得知目前扩容了多少个实例",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
          "name": "serverless"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjU1NjEwMzM=",
    "number": 302,
    "title": "【Q300】node 中 exec，fork 与 spawn 有何区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyMjAyMjg=",
    "number": 303,
    "title": "【Q301】base64 由哪64个字符构成",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTEwNjk2NQ==",
          "body": "`A-Z`，`a-z`，`0-9`，`+`，`/`",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNTg4NDQ=",
    "number": 304,
    "title": "【Q302】多服务器的系统时间不一致如何解决",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTIzODU5OA==",
          "body": "ntp服务",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "sk-xie",
            "url": "https://github.com/sk-xie"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjU0NzI4NDM2",
          "name": "linux"
        },
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzY4MDA=",
    "number": 305,
    "title": "【Q303】在 k8s 中如何自定义 CRD 资源",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjYyNzc5OTc=",
    "number": 306,
    "title": "【Q304】service mesh 是什么，能够解决什么问题",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjgxMzczMzQ=",
    "number": 307,
    "title": "【Q305】如何删除项目中没有使用到的 package",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNjYwMjUzMQ==",
          "body": "可以采用 [depcheck](https://github.com/depcheck/depcheck) 来完成这件事\r\n\r\n``` js\r\n$ npm install depcheck -g\r\n\r\n$ depcheck\r\nUnused dependencies\r\n* underscore\r\nUnused devDependencies\r\n* jasmine\r\nMissing dependencies\r\n* lodash\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTQ1OTU=",
    "number": 308,
    "title": "【Q306】如何实现左右固定，中间自适应布局",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkwOTU0MjE=",
    "number": 309,
    "title": "【Q307】如何实现表格单双行条纹样式",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDYzNzQ1MjAyOA==",
          "body": "通过 `css3` 中选择器 `:nth-child` 来实现\r\n\r\n``` css\r\ntr:nth-child(2n) {\r\n  background-color: red;\r\n}\r\n\r\n\r\ntr:nth-child(2n+1) {\r\n  background-color: blue;\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkxMDIxMjI=",
    "number": 310,
    "title": "【Q308】node 中 dns.resolve 及 dns.lookup 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkxMTMxNDk=",
    "number": 311,
    "title": "【Q309】简述下 css specificity",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MjkyNzA3MDM=",
    "number": 312,
    "title": "【Q310】Node 中 require json 文件数据时，如何当文件更新时，重新 require",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mjk3NzA2MTI=",
    "number": 313,
    "title": "【Q311】当 cookie 没有设置 maxage 时，cookie 会存在多久",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mjk4NTYxMjY=",
    "number": 314,
    "title": "【Q312】如何实现 Promise.race",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA0NjU4MTY=",
    "number": 315,
    "title": "【Q313】在浏览器中如何监听剪切板中内容",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MDk4NTczMg==",
          "body": "通过 `Clipboard API` 可以获取剪切板中内容，但需要获取到 `clipboard-read` 的权限\r\n\r\n``` js\r\nnavigator.clipboard.readText().then(text => console.log(text))\r\n```\r\n\r\n > 注: 该方法在 devtool 中不生效\r\n\r\n相关问题: [【Q019】如何实现选中复制的功能](https://github.com/shfshanyue/Daily-Question/issues/20)\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA2ODYyNDE=",
    "number": 316,
    "title": "【Q314】source 与 sh 执行脚本时有何区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTA5NjQyNTA2",
          "name": "shell"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDY1OTY=",
    "number": 317,
    "title": "【Q315】'+' 与 '~' 选择器有什么不同",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MTMzNDkzOQ==",
          "body": "+ `+` 选择器匹配紧邻的兄弟元素\r\n+ `~` 选择器匹配随后的所有兄弟元素",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NDg1MTU=",
    "number": 318,
    "title": "【Q316】node 中如何查看函数异步调用栈",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTAzMTY=",
    "number": 319,
    "title": "【Q317】有哪些 css 属性不能展示动画效果",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTI3ODk=",
    "number": 320,
    "title": "【Q318】如何设计 prometheus 中的 metric",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTMxNzg=",
    "number": 321,
    "title": "【Q319】css 动画与 js 动画哪个性能更好",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTQzNzI=",
    "number": 322,
    "title": "【Q320】如何衡量 serverless 的冷启动时间",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMDkxMTQ2MDM3",
          "name": "serverless"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA3NTk1Njk=",
    "number": 323,
    "title": "【Q321】 css 中属性选择器及类选择器的权重哪个高",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzA4NjYwNDg=",
    "number": 324,
    "title": "【Q322】有没有接触过 fs-extra，它是解决什么问题的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzE1MDA4MzQ=",
    "number": 325,
    "title": "【Q323】在 k8s 中如何通过日志查看某条请求进入的 pod",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzQyNTk1NjY=",
    "number": 327,
    "title": "【Q324】为什么会发生样式抖动",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzQzMjgzOTQ=",
    "number": 328,
    "title": "【Q325】关于 cors 的响应头有哪些",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MTYxNjcwNQ==",
          "body": "- `Access-Control-Allow-Origin`\r\n- `Access-Control-Allow-Methods`\r\n- `Access-Control-Allow-Headers`\r\n- `Access-Control-Allow-Credentials`\r\n- `Access-Control-Expose-Headers`\r\n- `Access-Control-Max-Age`\r\n\r\n关于如何写一个 `cors` 的中间件可以参考 [koajs/cors](https://github.com/koajs/cors)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUwODMwMTU=",
    "number": 329,
    "title": "【Q326】如何发现 redis 中的 bigkey",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjY2OTk3OTM5",
          "name": "redis"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUzMzk3NTg=",
    "number": 330,
    "title": "【Q327】如何避免 CDN 为 PC 端缓存移动端页面",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NzE1NTk1OA==",
          "body": "如果 PC 端和移动端是一套代码则不会出现这个问题。**这个问题出现在 PC 端和移动端是两套代码，却共用一个域名。**\r\n\r\n使用 `nginx` 配置如下，根据 UA 判断是否移动端，而走不同的逻辑 (判断UA是否移动端容易出问题)\r\n\r\n``` conf\r\nlocation / {\r\n    // 默认 PC 端\r\n    root /usr/local/website/web;\r\n    \r\n    # 判断 UA，访问移动端\r\n    if ( $http_user_agent ~* \"(Android|webOS|iPhone|iPad|BlackBerry)\" ){ \r\n        root /usr/local/website/mobile;\r\n    }\r\n \r\n    index index.html index.htm;\r\n}\r\n```\r\n\r\n解决方案通常使用 `Vary` 响应头，来控制 CDN 对不同请求头的缓存。\r\n\r\n**此处可以使用 `Vary: User-Agent` ，代表如果 User-Agent 不一样，则重新发起请求，而非从缓存中读取页面**\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n当然，`User-Agent` 实在过多，此时缓存失效就会过多。\r\n\r\n## 简答\r\n\r\n使用 `Vary: User-Agent`，根据 UA 进行缓存。\r\n\r\n``` txt\r\nVary: User-Agent\r\n```\r\n\r\n但最好不要出现这种情况，PC 端和移动端如果是两套代码，建议用两个域名，理由如下\r\n\r\n1. `nginx` 判断是否移动端容易出错\r\n1. 对缓存不友好\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzUzNDI3Mzk=",
    "number": 331,
    "title": "【Q328】简述 bloomfilter，及它的使用场景是什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
          "name": "data-structure"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0ODUwMTQ=",
    "number": 332,
    "title": "【Q329】什么是一致性哈希，可以解决什么问题",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
          "name": "data-structure"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTU1NDQ=",
    "number": 333,
    "title": "【Q330】mysql 如何开启及查看慢查询日志",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTcwMDI=",
    "number": 334,
    "title": "【Q331】当分页10000页时数据库查询 offset 过大如何解决性能问题",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzU0OTg5MTA=",
    "number": 335,
    "title": "【Q332】当数据库进行版本升级时，如何进行数据迁移",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzY0NTM=",
    "number": 336,
    "title": "【Q333】mysql 是如何实现 MVCC 的",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxNzk4NTc=",
    "number": 337,
    "title": "【Q334】position: sticky 如何工作，适用于哪些场景",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MTk0OTUzMA==",
          "body": "`position: sticky` 可理解为 `relative` 与 `fixed` 的结合体",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODE2NDM=",
    "number": 338,
    "title": "【Q335】什么是层叠上下文 (stacking contect)，谈谈对它的理解",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODgzNDQ=",
    "number": 339,
    "title": "【Q336】你用 css 实现过什么不错的效果",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxODkzNzY=",
    "number": 340,
    "title": "【Q337】你做前端有多少时间花在写 css 上",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEx",
          "name": "open"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTAwNTA=",
    "number": 341,
    "title": "【Q338】js 中在 new 的时候发生了什么",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTEwMjE=",
    "number": 342,
    "title": "【Q339】伪类与伪元素有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIw",
          "name": "css"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTM5MjU=",
    "number": 343,
    "title": "【Q440】试着讲述数据库的几个范式",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTUyNTQ=",
    "number": 344,
    "title": "【Q341】为什么在 mysql 不能够使用 = null",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzYxOTkwMDQ=",
    "number": 345,
    "title": "【Q342】`A, B` 复合索引时，`A=? and B=?` 与 `B=? and A=?` 效果是否一致",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY3NDk0Nzc=",
    "number": 346,
    "title": "【Q343】如何查找地图中某个点两公里内的餐厅",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwyMTI1MDM5MzMx",
          "name": "data-structure"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY3Nzg5NjA=",
    "number": 347,
    "title": "【Q344】如何列出所有已合并到 master 的分支并删除",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MjQ2MTk3MQ==",
          "body": "``` bash\r\n# 列出所有已合并到 master 的分支\r\n$ git branch --merged master\r\n\r\n# 删除所有已合并到 master 的分支\r\n$ git branch --merged master | grep -v '^\\*' | xargs git branch -d\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzE2ODAxMDI2",
          "name": "git"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzY5NzcxNjU=",
    "number": 348,
    "title": "【Q345】postgres 中 Index Scan 与 Index Only Scan 有何区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MjY3MjcyOQ==",
          "body": "假设在 `user` 表简历索引 (name, age)\r\n\r\nIndex Scan 指查询中除利用索引外还有额外的查询条件，如 (name, age) 是索引，但是 sex 不是\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10 and sex = 'MALE'\r\n```\r\n\r\nIndex Only Scan 指查询中可以全部利用索引，如 (name, age) 都是索引\r\n\r\n``` sql\r\nselect * from user where name = '张三' and age = 10\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzEz",
          "name": "db"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzc1NTM2Njk=",
    "number": 349,
    "title": "【Q346】Sentry 中 `withScope`，`configureScope` 与 直接 setTags 有何区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzc2NzEwNTE=",
    "number": 350,
    "title": "【Q347】在 node 中如何开启 https",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MzIxMjcxMw==",
          "body": "在 `express` 中开启 https，如下代码所示\r\n\r\n``` js\r\nimport path from 'path'\r\nimport fs from 'fs'\r\nimport express from 'express'\r\nimport http from 'http'\r\nimport https from 'https'\r\n\r\nconst app = express();\r\n\r\nconst cred = {\r\n  key: fs.readFileSync(path.resolve(__dirname, '../key.pem')),\r\n  cert: fs.readFileSync(path.resolve(__dirname, '../cert.pem'))\r\n}\r\nconst httpServer = http.createServer(app)\r\nconst httpsServer = https.createServer(cred, app)\r\n\r\nhttpServer.listen(8000);\r\nhttpsServer.listen(8888);\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgwODI1NDU=",
    "number": 351,
    "title": "【Q348】node 中 module.exports 与 exports 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxMzY2ODg=",
    "number": 352,
    "title": "【Q349】如何把 json 数据转化为 demo.json 并下载文件",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0MzYwMzAyNA==",
          "body": "json 视为字符串，可以利用 `DataURL` 进行下载\r\n\r\n`Text -> DataURL`\r\n\r\n除了使用 DataURL，还可以转化为 Object URL 进行下载\r\n\r\n`Text -> Blob -> Object URL`\r\n\r\n可以把以下代码直接粘贴到控制台下载文件\r\n\r\n``` js\r\nfunction download (url, name) {\r\n  const a = document.createElement('a')\r\n  a.download = name\r\n  a.rel = 'noopener'\r\n  a.href = url\r\n  // 触发模拟点击\r\n  a.dispatchEvent(new MouseEvent('click'))\r\n  // 或者 a.click()\r\n}\r\n\r\nconst json = {\r\n  a: 3,\r\n  b: 4,\r\n  c: 5\r\n}\r\nconst str = JSON.stringify(json, null, 2)\r\n\r\n// 方案一：Text -> DataURL\r\nconst dataUrl = `data:,${str}`\r\ndownload(dataUrl, 'demo.json')\r\n\r\n// 方案二：Text -> Blob -> ObjectURL\r\nconst url = URL.createObjectURL(new Blob(str.split('')))\r\ndownload(url, 'demo1.json')\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE2",
          "name": "html"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgxODI2ODI=",
    "number": 353,
    "title": "【Q350】如何实现一个 timeout 的中间件",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjk2MzM2ODQy",
          "name": "micro-service"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2MzgzMTkyNDk=",
    "number": 354,
    "title": "【Q351】如何得知目前 node 版本的 v8 版本号",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Mzc0MzQ5MQ==",
          "body": "在 `process.versions` 中可以查看 node 及相关依赖的版本号\r\n\r\n``` js\r\n> process.versions\r\n{\r\n  node: '12.16.3',\r\n  v8: '7.8.279.23-node.35',\r\n  uv: '1.34.2',\r\n  zlib: '1.2.11',\r\n  brotli: '1.0.7',\r\n  ares: '1.16.0',\r\n  modules: '72',\r\n  nghttp2: '1.40.0',\r\n  napi: '5',\r\n  llhttp: '2.0.4',\r\n  http_parser: '2.9.3',\r\n  openssl: '1.1.1g',\r\n  cldr: '36.0',\r\n  icu: '65.1',\r\n  tz: '2019c',\r\n  unicode: '12.1'\r\n}\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg0OTQ3MjU=",
    "number": 355,
    "title": "【Q352】k8s 中如何删除所有 Evicted 状态的 pod",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Mzg3MDI2OQ==",
          "body": "``` bash\r\n$ kubectl get pods\r\nNAME                                             READY   STATUS             RESTARTS   AGE\r\ncert-manager-5d8fd69d88-4nxw5                    1/1     Running            0          63d\r\ncert-manager-5d8fd69d88-f7f2w                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-mpgqq                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-s7dtg                    0/1     Evicted            0          232d\r\ncert-manager-5d8fd69d88-vdmrx                    0/1     Evicted            0          63d\r\ncert-manager-5d8fd69d88-zlpv4                    0/1     Evicted            0          63d\r\ncert-manager-cainjector-755bbf9c6b-455nm         0/1     Evicted            0          63d\r\n```\r\n\r\n可通过 `kubectl get pods` 来找到 `Evicted` 状态的 POD，通过 `awk` 和 `kubectl delete pod` 选中目标 pod 并删除，命令如下\r\n\r\n``` bash\r\n$  kubectl get pods | grep Evicted | awk '{print $1}' | xargs kubectl delete pod\r\n```",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2Mzg2NjQ5OTc=",
    "number": 356,
    "title": "【Q353】k8s 中 Deployment 与 StatefulSet 有什么区别",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjYwMTIxNDcw",
          "name": "k8s"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDExMTc0NDg=",
    "number": 357,
    "title": "【Q354】在 node 中如何判断一个对象是 stream",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDEyMTEzNTY=",
    "number": 358,
    "title": "【Q355】什么是 Iterable 对象，与 Array 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY0Njk5MTA4Mw==",
          "body": "实现了 `[Symbol.iterator]` 属性的对象即是 `Iterable` 对象，然后可以使用操作符 `for...of` 进行迭代\r\n\r\n``` js\r\n```\r\n\r\n详细参考 <https://javascript.info/iterable>",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDI0NzczMTE=",
    "number": 360,
    "title": "【Q356】在 node 端如何向服务器上传文件",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNzI2MDg3MTMx",
          "name": "node"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NDU2MTg2MDg=",
    "number": 361,
    "title": "【Q357】js 如何全部替代一个子串为另一个子串",
    "body": "假设有一个字符串 `hello. hello. hello. ` 需要替换为 `AAA`，即把 `hello. ` 替换为 `A`",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1MTU2NDM3Ng==",
          "body": "如果需要全量替换字符串，可以使用 `String.prototype.replace(re, replacer)`，其中正则表达式需要开启 `global` flag\r\n\r\n``` js\r\nconst s = 'foo foo foo'\r\ns.replce(/foo/g, 'bar')\r\n```\r\n\r\n那如题中，**是否可以使用正则表达式来替代子串**\r\n\r\n答：**不可以，因为使用子串构建正则时，有可能有特殊字符，就有可能出现问题**，如下\r\n\r\n``` js\r\n// 期待结果: 'AhelloX hello3 '\r\n> 'hello. helloX hello3 '.replace(new RegExp('hello. ', 'g'), 'A')\r\n< \"AAA\"\r\n```\r\n\r\n而在 `javascript` 中替换子串只能使用一种巧妙的办法：`str.split('foo').join('bar')`\r\n\r\n``` js\r\n> 'hello. hello. hello. '.split('hello. ').join('A')\r\n< \"AAA\"\r\n```\r\n\r\n真是一个巧(笨)妙(拙)的办法啊！！！！！**大概 TC39 也意识到了一个问题，于是出了一个新的 API**，在 `ESNext` 中\r\n\r\n``` js\r\nString.prototype.replaceAll()\r\n\r\n'aabbcc'.replaceAll('b', '.'); \r\n// 'aa..cc'\r\n```\r\n\r\n详细文档在 [String.prototype.replaceAll](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll)\r\n\r\n## 总结(及直接答案)\r\n\r\n两种办法\r\n\r\n+ `str.split('foo').join('bar')`\r\n+ `str.replaceAll('foo', 'bar')`，在 `ESNext` 中，目前支持性不好",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE4",
          "name": "js"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMxOTc1Njk=",
    "number": 363,
    "title": "【Q358】什么情况下会发送 OPTIONS 请求",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMzIyNQ==",
          "body": "[搬运地址](https://blog.csdn.net/kahhy/article/details/81563063)\r\n1:请求的方法不是GET/HEAD/POST\r\n2:POST请求的Content-Type 异常\r\n3:请求设置了自定义的header字段\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hedongxiaoshimei",
            "url": "https://github.com/hedongxiaoshimei"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        },
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTMzMzY1MjQ=",
    "number": 364,
    "title": "【Q359】CORS 如果需要指定多个域名怎么办",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NTg2Mjg2NA==",
          "body": "`CORS` 通过控制 `Access-Control-Allow-Origin` 控制哪些域名可以共享资源，取值如下\r\n\r\n``` bash\r\nAccess-Control-Allow-Origin: <origin> | *\r\n```\r\n\r\n其中 `*` 代表所有域名，`origin` 代表指定特定域名，那如何设置多个域名了？\r\n\r\n此时需要通过代码实现，**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，那 Origin 又是什么东西？\r\n\r\n## 请求头: Origin\r\n\r\n并不是所有请求都会自动带上 `Origin`，在浏览器中带 `Origin` 的逻辑如下\r\n\r\n1. 如果存在跨域，则带上 `Origin`，值为当前域名\r\n1. 如果不存在跨域，则不带 `Origin`\r\n\r\n逻辑理清楚后，关于服务器中对于 `Access-Control-Allow-Origin` 设置多域名的逻辑也很清晰了\r\n\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>`\r\n\r\n使用伪代码实现如下:\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n## Vary: Origin\r\n\r\n此时可以给多个域名控制 CORS，但此时假设有两个域名访问 `static.shanyue.tech` 的跨域资源\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`\r\n1. `bar.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: bar.shanyue.tech`\r\n\r\n看起来一切正常，但如果中间有缓存怎么办？\r\n\r\n1. `foo.shanyue.tech`，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，被 CDN 缓存\r\n1. **`bar.shanyue.tech`，因由缓存，响应头中返回 `Access-Control-Allow-Origin: foo.shanyue.tech`，跨域出现问题**\r\n\r\n此时，`Vary: Origin` 就上场了，代表为不同的 `Origin` 缓存不同的资源\r\n\r\n## 总结 (简要答案)\r\n\r\nCORS 如何指定多个域名？\r\n\r\n**根据请求头中的 `Origin` 来设置响应头 `Access-Control-Allow-Origin`**，思路如下\r\n\r\n1. 总是设置 `Vary: Origin`，避免 CDN 缓存破坏 CORS 配置\r\n1. 如果请求头不带有 `Origin`，证明未跨域，则不作任何处理\r\n1. 如果请求头带有 `Origin`，证明浏览器访问跨域，根据 `Origin` 设置相应的 `Access-Control-Allow-Origin: <Origin>` \r\n\r\n使用伪代码实现如下\r\n\r\n``` js\r\n// 获取 Origin 请求头\r\nconst requestOrigin = ctx.get('Origin');\r\n\r\nctx.set('Vary', 'Origin')\r\n\r\n// 如果没有，则跳过\r\nif (!requestOrigin) {\r\n  return await next();\r\n}\r\n\r\n// 设置响应头\r\nctx.set('Access-Control-Allow-Origin', requestOrigin)\r\n```\r\n\r\n>  相关问题：[如何避免 CDN 为 PC 端缓存移动端页面](https://github.com/shfshanyue/Daily-Question/issues/330)",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ0ODg0NjQ=",
    "number": 365,
    "title": "【Q360】localhost 与 127.0.0.1 有什么区别",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjUyMDM1Ng==",
          "body": "localhost 可以更改后指向其它地址。\r\n127.0.0.1 是约定的本机IP。\r\n类似互联网中域名与服务器IP的关系。",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "hedongxiaoshimei",
            "url": "https://github.com/hedongxiaoshimei"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzE0",
          "name": "network"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTQ1NzUyMDE=",
    "number": 366,
    "title": "【Q361】既然 cors 配置可以做跨域控制，那可以防止 CSRF 攻击吗 ",
    "body": "",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NjY5NzU2Nw==",
          "body": "**对 CORS 一点用也没有**\r\n\r\n1. **`form` 提交不通过 `CORS` 检测**，你可以在本地进行测试\r\n1.  即使通过 `xhr` 及 `fetch` 进行提交被 CORS 拦住，**但是对于简单请求而言，请求仍被发送**，已造成了攻击\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjgwMDkyMDA5",
          "name": "http"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODEwMjg=",
    "number": 367,
    "title": "【Q362】js 动画和 css 动画那个性能比较好",
    "body": "",
    "comments": {
      "nodes": []
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNzY5MDg5MzQ2",
          "name": "dom"
        }
      ]
    }
  },
  {
    "id": "MDU6SXNzdWU2NTU3ODM0NDM=",
    "number": 368,
    "title": "【Q363】如何获取当前系统中的在线用户数 (并发用户数)",
    "body": "一些 SaaS 系统基于 Pricing 的考虑，会限制团队人数及同时在线数，如何实现",
    "comments": {
      "nodes": [
        {
          "id": "MDEyOklzc3VlQ29tbWVudDY1NzUxMzc5Mw==",
          "body": "> 一些 SaaS 系统基于 Pricing 的考虑，会限制团队人数及同时在线数，如何实现\r\n\r\n",
          "star": {
            "totalCount": 0
          },
          "author": {
            "login": "shfshanyue",
            "url": "https://github.com/shfshanyue"
          }
        }
      ]
    },
    "labels": {
      "nodes": [
        {
          "id": "MDU6TGFiZWwxNjUxNDAyMzIy",
          "name": "server"
        }
      ]
    }
  }
]